%Made By Thomas Debelle
%Ajouté des Packages si nécessaires
\documentclass{report}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{colortbl}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{array}
\usepackage{amssymb}
\usepackage{colortbl}
\usepackage{color}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{xparse}
\usepackage{wrapfig}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={LINFO1123},
    pdfpagemode=FullScreen,
    }
\begin{document}

%Si la mention "Juin 2023" est sur une autre page, changé le dernier VSPACE
\begin{titlepage}
    \begin{figure}
        \includegraphics[height = 2cm]{UCL_Logo.png}
        \label{fig:my_label}
    \end{figure}

    \hspace*{100cm}
    \centering
    \vspace*{7cm}

    {\Huge \textbf{Résumé de LINFO1123}}\\
    \vspace*{0.25cm}
    compilation du \today\\
    \vspace*{0.25cm}
    \Large{Thomas Debelle}\\

    \vspace*{9.5cm} %Le dernier VSPACE
    {\Large Juin 2023}
\end{titlepage}

%_____NE PAS MODIFIER______
\setcounter{tocdepth}{1}
\tableofcontents
\newpage

\section*{Préface}

Bonjour à toi !\\

Cette synthèse recueille toutes les informations importantes données au cours, pendant les séances de tp et est amélioré grâce au note du Syllabus. Elle ne remplace pas le cours donc écoutez bien les conseils et potentielles astuces que les professeurs peuvent vous donner. Notre synthèse est plus une aide qui on l'espère vous sera à toutes et tous utiles.\\

Elle a été réalisée par toutes les personnes que tu vois mentionné. Si jamais cette synthèse a une faute, manque de précision, typo ou n'est pas à jour par rapport à la matière actuelle ou bien que tu veux simplement contribuer en y apportant ta connaissance ? Rien de plus simple ! Améliore la en te rendant \href{http://www.github.com/Tfloow/Q4_EPL}{ici} où tu trouveras toutes les infos pour mettre ce document à jour. (\textit{en plus tu auras ton nom en gros ici et sur la page du github})\\

Nous espérons que cette synthèse te sera utile d'une quelconque manière ! Bonne lecture et bonne étude.

%_______Vous pouvez modifier en-dessous_____
\chapter{Concepts}
Dans ce chapitre, on s'intéresse aux ensembles, cardinalité et équipotences de ces derniers
\section{Ensemble}
Un ensemble est une \textit{collection} d'objets, \textit{sans répétition}, ces derniers sont appelés \textit{éléments} de l'ensemble.
Donc un ensemble peut être des chiffres, des lettres, il peut être vide symbolisé par $void$ %à ajouter
On peut réaliser des opérations dessus, on peut déterminer des \textit{sous-ensembles d'ensemble} donc des ensembles issus d'ensemble.
On a également une notion s'appelant le \textit{complément} d'un ensemble dénoté $\overline{A}$\\%trouver le bon charactère

\subsubsection{Langage}
Un \textit{langage} n'est autre qu'un mot ou bien un ensemble de caractères d'une taille fixée. Une chaine vide est écrite via le caractère "$\epsilon$".\\
On forme un langage via un \textit{alphabet} qui n'est autre qu'un ensemble de symboles, on le dénote "$\Sigma$". Tout langage est donc une suite de symbole issue de l'\textit{alphabet}.\\
$\Sigma^*$ correspond à l'ensemble des langages formés via l'alphabet.

\subsubsection{Relations}
Lorsque nous avons deux ensembles appelés \textit{A} et \textit{B}, on peut établir une relation appelé \textcolor{brown}{R} qui nous donne un sous-ensemble $AXB$ %trouver le symbole pour cross product
On peut représenter la relation par une table.

\subsubsection{Fonctions}
Lorsque nous avons deux ensembles appelés \textit{A} et \textit{B}, on peut avoir ce qu'on appelle une \textit{fonction} \textcolor{brown}{F}. C'est une relation tel que:
\begin{equation}
\exists a \in A : \exists b \in B :\quad <a,b> \quad \in f
\end{equation}
Il n'existe pas plus d'un b pour un a. Si pour un a il n'existe pas de b, on dit que $f(a)$ est indéfini et donc $f(a) = \perp$ ou \textit{bottom}.

\subsubsection{Propriétés des fonctions}
\begin{itemize}
\item un \textcolor{brown}{domaine de fonction} ou dom(f) $= {a \in A | f(a) \neq \perp}$
\item une \textcolor{brown}{image de fonction} ou image(f) $= b \in B | \exists a \in A: b = f(a)$
\item f est dit \textcolor{brown}{fonction totale} si dom(f) $= A$
\item f est dit \textcolor{brown}{fonction partielle} si dom(f) $\in A$ % trouver le symbole pour include
\item f est \textcolor{brown}{surjectif} ssi image(f) = B autrement dit, tout élément est associé à minimum 1 élément dans B.
\item f est \textcolor{brown}{injectif} ssi $\forall a, a' \in A: a \neq a' \Rightarrow f(a)\neq f(a')$ autrement dit on ne fait correspondre qu'au plus un élément de A dans B.
\item f est \textcolor{brown}{bijectif} s'il combine \textit{surjectif} et \textit{injectif}
\end{itemize}

Intéressons nous aux \textcolor{red}{extensions} qui est le fait de rajouter une fonction qui ne définit un élément de B pas encore défini.
\begin{equation}
\forall x \in A : g(x) \neq \perp \Rightarrow f(x) = g(x)
\end{equation}	
f à la même valeur que g partout où g est défini.

\subsubsection{Définition d'une fonction}
Comme dit précédemment, une fonction est défini par sa table. On va souvent utiliser une description de la table qui permet que celle-ci soit clair et bien défini. De plus, on n'a pas besoin de savoir comment calculer ceci.\\
On peut également définir une table via une fonction ou un algorithme.

\section{Ensemble énumérable}
On dit que 2 ensembles ont le même cardinal (\textit{A} et \textit{B}) ssi il existe une bijection entre ces 2 ensembles. Donc chaque élément de \textit{A} correspond à un élément de \textit{B}.\\

On dit d'un ensemble qu'il est dénombrable ssi il est \textcolor{red}{fini} ou il existe une \textcolor{red}{bijection} entre l'ensemble $\mathbb{N}$ et cet ensemble.

\subsubsection{Exemples}
\begin{itemize}
\item L'ensemble $\mathbb{Z}$
\item L'ensemble des nombres pairs
\item Des paires d'entiers
\item L'ensemble des programmes Java
\end{itemize}

\subsubsection{Propriétés}
Tout sous-ensemble d'ensemble énumérable est \textit{énumérable}. L'union et l'intersection d'ensembles énumérables est \textit{énumérable}.\\

En s'intéressant à l'ensemble des programmes informatiques, on se rend compte que c'est un \textit{ensemble énumérable infini}. De plus, les programmes informatiques ne considèrent que des choses \textit{énumérables}.

\section{Cantor}
Le théorème de \textit{Cantor} nous dit que l'ensemble des nombres entre 0 et 1 compris est \textit{non énumérable}.
\begin{equation}
E = {x \in \mathbb{R} | 0 < x \le 1}
\end{equation}

\subsubsection{Preuve}
Pour prouver cela, on va réaliser une table et on va réaliser une \textit{diagonalisation de Cantor}.
\begin{center}
\begin{tabular}{|c||c|c|c|c|c|}
	\hline
	 & chiffre 1 & chiffre 2 & ... & chiffre $k+1$ & ...\\
	 \hline
	 $x_0$ & \textcolor{red}{$x_{00}$} & $x_{01}$ & ... & $x_{0k}$ & ...\\
	 \hline
	 $x_1$ & $x_{10}$ & \textcolor{red}{$x_{11}$} & ... & $x_{1k}$ & ...\\
	 \hline
	 ...& ... & ... & ... & ... & ...\\
	 \hline
	 $x_k$ & $x_{k0}$ & $x_{k1}$ & ... & \textcolor{red}{$x_{kk}$} & ...\\
	\hline
	 ...& ... & ... & ... & ... & ...\\
	\hline
\end{tabular}
\end{center}
Ensuite, on va définir notre nombre de la diagonale qui vaut $d = 0.x_{00}x_{11}...x_{kk}$. De cet valeur, on va créer une valeur $d'$ qui a comme propriété $x_{kk} \neq x'_{kk} \forall k$.\\
Mais, on doit stocker notre valeur $d'$ dans la table. On la stock à $p$ ce qui donne $d' = 0.x'_{p0}x'_{p1}... \textcolor{red}{x'_{pp}}$ mais à cause de la construction de $d = 0.x_{00}x_{11}...\textcolor{red}{x_{pp}}$. Par construction, $x'_{pp} \neq x_{pp}$ mais cela ne peut être respecté. Donc, \textbf{il n'y a pas} de \textit{bijection} des $\mathbb{N}$ vers cet ensemble. Donc cet ensemble est \textit{non énumérable}.

\subsubsection{Autre ensemble non énumérable}
\begin{itemize}
\item L'ensemble des $\mathbb{R}$.
\item L'ensemble des sous-ensemble de $\mathbb{N}$.
\item L'ensemble des chaines infinies de caractères d'un alphabet fini.
\item L'ensemble des \textit{fonctions} de $\mathbb{N}$ dans $\mathbb{N}$.
\end{itemize}
Chose intéressante à noter, comme on a une infinité non énumérable de fonctions $\mathbb{N}$ dans $\mathbb{N}$ et un nombre de programme informatique \textit{infini énumérable}. On ne peut pas résoudre tous les problèmes informatiques donc.

\chapter{Programmes calculables}
\section{Les algorithmes}
Un algorithme est un ensemble \textit{d'instructions} qui a pour but de produire un résultat. Donc un algorithme n'est \textcolor{red}{pas une fonction}. Il \textit{calcule} une fonction. Un algorithme n'est pas forcément un \textit{programme}, il peut être un \textit{organigramme}. C'est un \textit{ensemble fini d'instructions}. C'est une sorte de \textit{calculateur}. Ici, on va considérer nos algorithmes comme \textit{n'ayant pas de limite} de:
\begin{itemize}
\item Taille de données
\item Taille d'instructions
\item Taille de la mémoire, mais on a une utilisation finie.
\end{itemize}

\subsection{Calculabilité}
Avant de continuer, il faut définir la \textit{calculabilité} des algorithmes car sans \textit{formalisme}, les algorithmes sont non rigoureux, non exploitables.\\

Ici, on base cette notion sur celle des \textit{programmes informatiques}. (plus intuitif).
Ainsi, on possède \textbf{2 univers} celui des \textit{programmes informatiques} et celui des \textit{problèmes}. Pour être plus précis, on se base sur le \textcolor{brown}{langage Java} et on se limite au fonction $\mathbb{N} \rightarrow \mathbb{N}$. Ainsi pour les fonctions, on aura \textbf{1 entrée} et \textbf{1 sortie}. (on peut également généraliser ceci en disant que $\mathbb{N}^n \rightarrow \mathbb{N}$)

\section{Fonction calculable}
Une fonction est dite \textit{calculable} s'il existe un \textit{programme Java} recevant \textbf{1 donnée} étant un nombre $\in \mathbb{N}$ et la fonction va nous retourner la \textit{valeur} de $f(x)$ \textit{si} elle est défini.\\
Si le programme \textit{ne se termine pas} donc pas défini ou erreur d'exécution on dit que $f(x) = \perp$. On définit bien la notion de calculabilité sur \textit{l'existence d'un programme}. on a 2 types de fonctions
\begin{enumerate}
\item Fonction \textit{partielle} calculable: on a \textit{parfois} un résultat
\item Fonction \textit{totale} calculable: on peut \textit{toujours} calculé quelque chose.
\end{enumerate}

\subsection{Ensemble récursif}
Maintenant, on va essayer de déterminer la calculabilité sur \textit{un ensemble de fonctions}.
Le principe de décision de \textit{calculabilité} est le principe dit \textit{récursif}.\\
\textbf{A} est \textcolor{red}{récursif} si il existe un programme \textit{Java} qui recevant n'importe quelle donnée sous forme d'un $\mathbb{N}$ fourni comme résultat:
\begin{itemize}
\item 1 si $x \in A$
\item 0 si $x \notin A$
\end{itemize}
Donc on est face à un \textit{algorithme} qui calcule si $x$ est dans A ou non. C'est un algorithme complet et se termine toujours. (attention de ne pas confondre \textit{récursif} et \textit{récursivité})\\

On dit qu'un ensemble d'algorithme est \textcolor{red}{récursivement énumérable} s'il est \textit{récursif} sauf qu'il retourne $\neq 1 \quad x \notin A$ ou ne se termine pas et qu'on puisse énuméré cet ensemble.

\subsubsection{Fonctions caractéristiques} \label{caract}
Une fonction caractéristique de $A \subseteq N$ et:
\begin{align*}
X_A : N \rightarrow N : X_A(x) &= 1 \text{ si } x \in A\\
&= 0 \text{ si } x \in A
\end{align*} 
C'est une autre manière de déterminer si un ensemble est récursif si $X_A$ est une fonction \textit{calculable}.\\
On dit qu'une fonction est récursivement énumérable ssi il existe une fonction f calculable ayant pour domaine A. Ou bien, on dit que A est vide \textit{ou} l'image de f est A ayant une fonction f \textit{totale} calculable.\\
Un \textcolor{red}{ensemble récursivement \textit{énumérable}} est un ensemble dont la bijection des $\mathbb{N}$ est énumérable et calculable.

Propriétés:
\begin{itemize}
\item A récursif $\Rightarrow$ A récursivement énumérable 
\item A récursif $\Rightarrow \mathbb{N}\vert_A$ récursivement énumérable 
\item A récursif $\Rightarrow \mathbb{N}\vert_A$ récursif 
\item A récursivement énumérable et $\mathbb{N}\vert_A$ récursivement énumérable $\Rightarrow$ A récursif 
\item A fini $\Rightarrow$ A récursif
\item $\mathbb{N}\vert_A$ fini $\Rightarrow$ A récursif
\item A récursif $\Rightarrow$ $\bar{A}$ récursif
\end{itemize}

\section{Thèse de Church-Turing}
Comment démontrer qu'une fonction \textbf{n'est pas} calculable.\\
Les 4 grands points de la thèse:
\begin{enumerate}
\item Aucun modèle de la notion de fonction calculable n’est plus puissant que les Machines de Turing (ici Java)
\item Toute fonction calculable (au sens intuitif) est calculable par une machine de Turing (ici Java)
\item Toutes les définitions formelles de la calculabilité connues à ce jour sont équivalentes (Théorème)
\item Toutes les formalisations de la calculabilité établies par la suite seront
équivalentes aux définitions connues
\end{enumerate}
On établit que Java a accès à une infinité de mémoire (donc physiquement impossible). Ainsi, on a $P$ qui est l'ensemble des programmes Java syntaxiquement corrects, qui reçoivent 1 données \textit{entières} et qui retournent un résultat \textit{entier}.
\begin{itemize}
\item P est un ensemble récursif (infini dénombrable)
\item $P = P_0, P_1, ..., P_k, ...$ sans répétition donc chaque programme est unique.
\item Pour simplifier, $f(k) = P_k$
\item f est calculable.
\item k et $P_k$ représente le même objet
\end{itemize}

donc on dit que $P_k$ donne le programme $k$ dans l'ensemble $P$. on dit que $\varphi_k$ est la fonction mathématique calculé par $P_k$. Donc on peut avoir $\varphi_m = \varphi_n$ car réalise le même travail mais sont issues de programmes \textit{différents}. $\varphi_k: N \rightarrow N$. 

\section{Non calculabilité}
Pour rappel:
\begin{itemize}
\item Nombre de fonctions de $\mathbb{N} \rightarrow \mathbb{N}$ est \textbf{non} dénombrable.
\item Nombre de programmes Java est dénombrable.
\end{itemize}
En programmation, on s'intéresse aux fonctions définies de manière finie, donc on a une \textcolor{red}{infinité dénombrable}. Mais si une fonction est définie de manière finie, peut-elle être calculable ?

\subsection{Problème de l'arrêt}
Une fonction prends 2 paramètres: halt: P x N. P est le numéro du programme et N est son entrée.\\
\begin{align*}
\text{halt}(n,x) &= 1 \text{ si } \varphi_n(x) \neq \perp\\
&= 0 \text{ sinon}\\
\text{halt}(n,x) &= 1 \text{ si l'exécution du } P_n \text{ se termine}\\
&= 0 \text{ sinon}
\end{align*}
On a donc une table finie, mais décrite de manière finie donc bien définie. Peut-on la calculer ?

\subsubsection{Preuve par l'absurde} 

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
& $0$ & $1$ & ... & $k$& ...\\
\hline
$P_0$ & \textcolor{red}{halt(0,0)} & halt(0,1) & ... & halt(0,k) & ...\\
\hline
$P_1$ & halt(1,0) & \textcolor{red}{halt(1,1)} & ... & halt(1,k) & ...\\
\hline
... & ... & ... & ... & ... & ... \\
\hline
$P_k$ & halt(k,0) & halt(k,1) & ... & \textcolor{red}{halt(k,k)} & ...\\
\hline
... & ... & ... & ... & ... & ... \\
\hline
\end{tabular}
\end{center}

On va sélectionner les valeurs sur la diagonale et stocker cela comme une variable s'appelant "\textit{diag}". On va donc modifier cette valeur et est représenté par "\textit{$diag_{mod}$}" qui inverse chaque nombre. (donc $0 \rightarrow 1$ et $1 \rightarrow 0$) Donc \textit{$diag_{mod}$} est calculable sous l'hypothèse que la fonction "halt" l'est.\\

Donc, il existe un programme Java qui calcule cette "$diag_{mod}$" qu'on trouvera en ligne $d$. Mais à cause de cela, $diag_{mod}(d) \neq diag(d)$ donc ne peut exister par \textit{définition}.\\

En conclusion, la fonction "halt" \textbf{n'est pas} calculable.

\subsubsection{Conclusion}
\begin{itemize}
\item  Aucun algorithme ne permet de déterminer pour tout programme $P_n$ et donnée $x$ si $P_n(x)$ se termine ou non
\item Seule possibilité serait d’avoir un langage de programmation dans lequel tous les programmes se terminent. La fonction halt est alors calculable pour les programmes de ce formalisme
\item halt non calculable ne signifie pas que pour un programme k donné, halt(k,x) est
non calculable
\end{itemize}
Pour le premier point, on ne peut séparer le soucis en 2 algorithmes car on ne peut changer de programmes selon l'input. Un algorithme donne le \textbf{bon résultat} en fonction du résultat.\\

On dit que halt n'est pas calulable dans le sens où il n'existe pas d'algorithmes \textbf{généraux}.

\subsubsection{Exemple non-récursif}

\begin{align*}
Halt &= \{(n,x) | \text{ halt}(n,x) = 1\}\\
&= \{(n,x) | P_n (x) \text{ se termine}\}\\
K &= \{n | (n,n) \in \text{HALT}\}\\
&= \{n | halt(n,n) = 1\}\\
&= \{n | diag(n) = 1\}\\
&= \{n | P_n(n) \text{ se termine}\}\\
\end{align*}
Donc K et HALT \textbf{ne sont pas} récursifs mais sont récursivement énumérable car si un élément n'appartient pas à K ou HALT, il va boucler mais fournir la bonne solution s'il appartient à ces ensembles.\\
De plus K est la diagonale de \textit{HALT}.

$\overline{HALT}$ n'est pas récursivement énumérable car on a pas de moyen de prouver qu'un élément probable n'appartient pas à cet ensemble. pareil pour $\overline{K}$

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{img/ensembleFonction.png}
\caption{Schématisation des fonctions et ensembles de fonctions}
\end{figure}

Le fait de ne pas pouvoir calculer "halt" nous pose soucis et va ouvrir tout un pan de soucis et limitations.\\

De plus, on peut faire face à des ensembles \textbf{co-récursivement} énumérable. En effet, il existe des ensembles co-récursivement énumérable tel que: $\overline{\textbf{K}}$ et tous les ensembles \textit{récursifs}. \label{coreq}

\section{Insuffisance des fonctions totales}
Pourquoi est-ce utile d'avoir un programme qui tourne en \textit{boucle}? N'avons-nous pas besoin de fonctions qui donnent un résultat précis tout le temps donc \textit{totale}?

Imaginons que nous créons un \textit{langage de programmation} qui a que des fonctions totales.
Donc, \textbf{Halt} est calculable et on a une réponse pour toutes fonctions. Halt serait la fonction constante 1.

Notre langage \textit{Q} est calculable donc ayant un interpréteur calculable.

\subsection{Théorème de Hoare-Allison} \label{HA}
Donc en résumé de notre langage \textit{Q}:
\begin{itemize}
\item L'interpréteur de ce programme est calculable
\item La fonction \textit{halt} est totale et correspond à la fonction constante de 1.
\item Mais l'interpréteur \textcolor{red}{n'est pas} calculable \textit{dans Q}.
\end{itemize}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
& $0$ & $1$ & ... & $k$& ...\\
\hline
$Q_0$ & \textcolor{red}{interpret(0,0)} & interpret(0,1) & ... & interpret(0,k) & ...\\
\hline
$Q_1$ & interpret(1,0) & \textcolor{red}{interpret(1,1)} & ... & interpret(1,k) & ...\\
\hline
... & ... & ... & ... & ... & ... \\
\hline
$Q_k$ & interpret(k,0) & interpret(k,1) & ... & \textcolor{red}{interpret(k,k)} & ...\\
\hline
... & ... & ... & ... & ... & ... \\
\hline
\end{tabular}
\end{center}
La colonne \textit{Q} correspond à l'ensemble des programmes et la ligne de nombre correspond aux entrées de chaque programme.

Tous les programmes se terminent donc \textit{jamais} $\perp$. On sélectionne la diagonale:
\begin{align*}
diag(n) &= interpret(n,n)\\
diag_{mod}(n) &= interpret(n,n) + 1\\
Q_l &= diag_{mod}
\end{align*}
Et donc, on voit facilement que à la ligne $l$ il y aura un souci avec $diag$ et notre entrée à $Q_l$ qui n'est autre que $diag_{mod}$. en effet $diag_{mod}(l) \neq diag(l)$. Donc la fonction \textit{interpret} n'est \textbf{pas} calculable en \textit{Q}.\\

Le \textit{théorème} nous dit donc que: Si un langage de programmation (non trivial) ne permet que le calcul de fonctions totales, alors: 
\begin{itemize}
\item l’interpréteur de ce langage n’est pas programmable dans ce langage 
\item il existe des fonctions totales non programmables dans ce langage
\item ce langage est \textcolor{red}{restrictif}
\end{itemize}

Donc si on peut faire un interpréteur d'un langage dans son langage, la fonction \textit{halt} n'est pas totale. Donc c'est soit programmable par lui-même soit fonction totale de halt.\\

Si on veut qu’un langage de programmation permette la programmation de toutes les fonctions totales calculables, alors ce langage doit également permettre
la programmation de fonctions non totales.\\

De plus, si on avait une fonction qui regarde si des fonctions sont totales, cela pose problème. Cela est impossible et donc cette fonction $tot(n)$ n'est pas récursif.

\subsection{Interpréteur}
Pour qu'un formalisme soit assez puissant, il faut que ce dernier arrive à programmer son propre interpréteur.

\begin{equation}
\exists z \forall n,x : \varphi_z(n,x) = \varphi_n(x)
\end{equation}
Avec $\varphi_z$ qu'on appelle la fonction universelle. et $P_z$ est le programme universel. Par convention, on appelle $\theta(n,x)$ la \textcolor{red}{fonction universelle}.

\section{Extension des fonctions partielles}
Pour l'instant, nous n'avons vu que des fonctions qui soit donnent le bon résultat soit donne $\perp$ et donc boucle. On va réaliser des \textit{extensions}, c'est-à-dire que nous allons retourner la valeur correcte dans les cas possible et un message ou autre chose pour le reste des entrées.\\

Un \textit{théorème} nous dit que, \textit{Il existe une fonction partielle calculable g telle qu’aucune fonction totale calculable n’est une extension de g}.\\
Pour prouver cela, on utilise la fonction \textit{nbstep(n,x)} qui correspond au nombre d'instruction avec l'arrêt de $P_n(x)$. ($P_n(x) = \perp$)La preuve se fait pas diagonalisation comme avant (\href{http://ezcast.uclouvain.be/ezplayer/index.php?action=view_asset_bookmark&album=LINFO1123-pub&asset=2021_02_17_21h51_34s&t=224&type=cam&token=EVKUMNQV}{vidéo}).\\

\section{Théorème de Rice}
\subsection{Réduction à Halt}
Pour montrer que f(x) est non calculable on suppose que:
\begin{itemize}
\item f(x) est calculable.
\item Sous cette hypothèse la fonction halt(n,x) est alors calculable.
\item Comme halt(n,x) est enfaite non-calculable, f(x) est également non-calculable.
\end{itemize}

\subsubsection{Raisonnement}
Définissons une fonction qui dit que:
\begin{align*}
f(n) &= 1 \quad \text{ si } \varphi_n(x) = \perp\\
&= 0 \quad \text{ sinon}
\end{align*}
On suppose que $f(n)$ est calculable et on veut montrer que halt est calculable. Pour se faire:
\begin{enumerate}
\item On \textcolor{red}{construit} (pas exécute) un programme qui dit: $P(z) \equiv P_n(x); print(1)$
\item On obtient le numéro de programme: $d = \text{ numéro de programme } P(z)$
\item On regarde si le résultat de cette fonction calculable pour créer halt:
\begin{lstlisting}[escapechar=\%]
if F(d) = 1 then
	print(0) %//\textit{car le programme se termine}%
else
	print(1) %//\textit{car on est bottom et cela boucle}%
\end{lstlisting}
\item Donc on en conclue que cette fonction halt est non-calculable
\end{enumerate}
On utilise ce type de démarche pour tout autre fonction du même genre. (on doit impérativement définir le comportement de la fonction)

\subsection{Théorème}
On s'intéresse à comparer des programmes entre eux, savoir si un programme est correct.
\subsubsection{Idée de base}
Dans l'ensemble des programmes, on va séparer cet ensemble en 2 \textit{sous-ensembles}.
\begin{figure}[H]
\centering
\includegraphics[width=6cm]{img/rice.png}
\end{figure}
On a que:
\begin{align*}
\text{Soit } A &\subseteq \mathbb{N}\\
\text{Si } A \text{ récursif et } A \neq \varnothing &\text{ et } A \neq \mathbb{N}\\
\text{Alors } \exists i \in A &\text{ et } j \in \mathbb{N} \setminus A : \varphi_i = \varphi_j 
\end{align*}
Ce qui revient à dire que:
\begin{align*}
\text{Si } \forall i \in A &\text{ et } \forall j \in \mathbb{N} \setminus A: \varphi_i \neq \varphi_j\\
\text{Alors } A \text{ non récursif \textit{ou} } &A = \varnothing \text{ ou } A = \mathbb{N}
\end{align*}
De plus, si un programme est récursif, on peut savoir de quel ensemble il est.

\subsubsection{Compréhension}
\begin{enumerate}
\item \textcolor{red}{Si} une propriété de programmes, vérifiée par certains programmes mais pas tous, est décidable, \\
\textcolor{red}{alors} il existe deux programmes équivalents (calculant la même fonction) dont un vérifie la propriété et l'autre pas
\item \textcolor{red}{Si} une propriété de la fonction calculée par un programme est vérifiée par certains programmes, mais pas par tous, \\
\textcolor{red}{alors} cette propriété ne peut être décidée par un algorithme
\item \textcolor{red}{S'il} existe un algorithme permettant de déterminer si un programme quelconque calcule une fonction ayant cette propriété, \\
\textcolor{red}{alors} toutes les fonctions calculables ont cette propriété ou aucune fonction
calculable n’a cette propriété
\end{enumerate}
Voyons plus en détail ce que chacun veut dire:
\begin{enumerate}
\item C'est une simple traduction du théorème en français.
\item Cela signifie qu'on ne peut pas vérifier si 2 programmes sont équivalents !
\item Autre façon d'énoncer le théorème de \textit{Rice}.
\end{enumerate}

\subsection{Exemple}
Commençons avec: $ A_1 = \{i | \varphi_i \text{ est totale}\}$ ($P_i$ s'arrête toujours)\\
Donc on sait que $A_1 \neq \varnothing$ car on a une fonction $P_k(x) \equiv print(1)$ et on sait ainsi que $k \in A_1$. Ce n'est pas $A_1 \neq \mathbb{N}$ car $P_l(x) \equiv while true$ n'est pas total ! De plus, notre ensemble $A$ a des fonctions totales et l'ensemble $\overline{A}$ des fonctions non-totales, par construction: $\forall i \in A \text{ et } \forall j \in \mathbb{N}: \varphi_i \neq \varphi_j$\\

Via le théorème de \textit{Rice}, $A_1$ est un ensemble non-vide et non égale à $\mathbb{N}$. On a également prouvé que les fonctions ne sont pas égales entre les 2 \textit{ensembles}. On en \textit{conclut} que l'ensemble \textbf{n'est pas récursif}.

\subsection{Analyse du théorème}
Bonne nouvelle, on est pas remplaçable (ou presque).
\begin{enumerate}
\item Aucune question relative aux programmes, vus sous l'angle de la \textbf{fonction} qu'ils calculent, ne peut être décidée par l'application d'un algorithme
\item Les propriétés intéressantes d'un programme concernent la fonction qu'il calcule, non pas la forme (syntaxe) du programme
\item La plupart des problèmes intéressants au sujet des programmes sont non
calculables
\end{enumerate}
Mauvaise, on ne peut pas automatiser qu'un programme est correct.

\subsection{Démonstration}
Supposons que $A \neq \varnothing$ et $A \neq \mathbb{N}$. Et on suppose que $\forall i \in A, \forall j \in \overline{A}: \varphi_i \neq \varphi_j$ Donc $A$ ne peut être récursif. On va \textbf{démontrer} cela.\\

Pour prouver cela on va utiliser une réduction à \textit{halt}. On fait les choses suivantes:
\begin{enumerate}
\item On suppose que $A$ est récursif.
\item Donc halt est calculable mais ce n'est pas le cas.
\item Donc $A$ est n'est pas récursif.
\end{enumerate}
On va donc séparer notre ensemble des Programmes et on effectue ces manipulations:
\begin{enumerate}
\item $\mathbb{N}$ en $A$ et $\overline{A}$. On dit que $P_k(x) \equiv while \quad true$ et que $k \in \overline{A}$
\item On sait que $A \neq \varnothing, \exists m \in A$ (on sait que c'est différent du vide donc il existe au moins 1 programme quelconque)
\item On peut affirmer que (par hypothèse de récursif) $\varphi_k \neq \varphi_m$
\item On crée un programme pour \textit{halt}:
	\begin{itemize}
	\item On construit: $P(z) \equiv P_n(x); P_m(z)$
	\item On assigne un numéro de programme qu'on a construit: $d = \#P(z)$. Cela dépend de ma donnée $n$ et $x$.
	\item on exécute un programme qui regarde si $d \in A$ il print $1$ qu'il appartient sinon il imprime $0$.
	\end{itemize}
\item On exécute le programme: si $P_n(x)$ se \textbf{termine} alors $\varphi_d = \varphi_m$. \textbf{Sinon} il boucle et est $\varphi_d = \varphi_k = \perp$
\item Donc aucun programme dans $A$ et $\overline{A}$ n'est équivalent. Donc tester que $\varphi_d = \varphi_m$ est la même chose que tester que $d \in A$ et inversement.
\item Donc, \textcolor{red}{Halt est non calculable} car il boucle, donc A est bien \textbf{non récursif}.
\end{enumerate} 


\section{Théorème de la paramétrisation}
De manière générale, une fonction peut être vu comme $f: \mathbb{N} \rightarrow \mathbb{N}$ mais \textit{également} comme $f: P \rightarrow P$. Donc $f(a) = b$ et en combinant $P_a = P_B$ notre $f$ devient un \textbf{transformateur de programmes}. Pour être plus précis c'est le $P_k$ qui calcule $f$ qui est le \textit{transformateur de programmes}.

\subsection{Théorème S-m-n via S-1-1}
On dit qu'il existe une fonction calculable qui prend 2 arguments tel que:
\begin{align*}
S_1^1 : N^2 &\rightarrow N \text{ et } \forall k\\
\varphi_k^{(2)} (x_1, x_2) &= \varphi_{S_1^1 (k,x_2)} (x_1)
\end{align*}
\subsubsection{Compréhension}
On dit qu'il existe un \textit{transformateur} ($S_1^1$) qui prend en arguments: - Un numéro de programme à 2 arguments - 1 valeur $v_2$\\
Cela donne comme résultat un programme $P_l(x_1)$ qui calcule la même chose que $P_k(x_1,v_2)$.

\subsection{Via S-m-n}
On dit que:
\begin{align*}
\forall m, n &\geq 0, \exists S_n^m : N^{m+1} \rightarrow N : \forall k\\
\varphi_k^{n+m} (x_1, ..., x_n, x_{n+1}, ..., x_{n+m}) &= \varphi_{S_n^m (k, x_{n+1}, ..., x_{n+m})}^{(n)} (x_1, ..., x_n)
\end{align*}
\subsubsection{Compréhension}
Comme nous avons $m,n \geq 0$, il existe un transformateur de programmes appelés $S_n^m$ qui reçoit: - $P_k$ avec $m+n$ arguments, $m$ valeurs $v_1, ..., v_m$\\
Cela renvoi comme résultat un programme P à $n$ arguments. Donc $P(x_1, ..., x_n)$ calcule la \textit{même} fonction que $P_k(x1, ..., x_n, x_{n+1}, ..., x_{n+m})$

\section{Théorème du point fixe}
C'est un résultat qui montre que quelque chose est possible.
\subsection{Définition}
Si on a une fonction $f$ qui est \textbf{totale calculable}, je sais qu'il existe $k$ tel que:
\begin{equation}
\varphi_k^{(n)} = \varphi_{f(k)}^{(n)}
\end{equation}
Pour tout transformateur (notre fonction totale calculable) de programme T, il existe deux programmes $P_k$ et $P_j$ tels que:
\begin{enumerate}
\item $P_j$ est la transformation de $P_k$ via $T$
\item $P_k$ et $P_j$ calculent la même fonction (qui n'est pas nécessairement totale)
\end{enumerate}

\subsection{Applications}
\begin{itemize}
\item Il existe un programme $P_n$ tel que $P_n$ ne s'arrête que pour la donnée $n$.
\item Il existe un programme $P_n$ tel que $P_n$ donne toujours $n$ comme résultat.
\item $K = \{n | \varphi_n (n) \neq \perp \}$ n'est pas récursif.
\item Transformateur de programmes qui remplaces les $+$ en $-$.
\end{itemize}

\subsubsection{Démonstration pour K}
Si on a un programme $\varphi_n (x) = \perp$ $\forall x$ (boucle tout le temps) et un autre $\varphi_m (x) = x$ $ \forall x$. On définit une fonction:
\begin{align*}
f(x) &= n \text{ si } x \in K\\
&= m \text{ si } x \notin K
\end{align*}
Donc $f$ est totale et calculable si $K$ est \textbf{récursif}. On va appliquer le \textcolor{blue}{point fixe}: $\exists k: \varphi_k = \varphi_{f(k)}$. Mais $k \in K$ ?\\
\underline{Si c'est le cas}: alors $f(k) = n$ par définition de $f$. Donc $\varphi_k (k) = \varphi_n (k)$ via le point fixe. Mais $\varphi_k (k) \neq \perp$ car appartient à $K$ mais $\varphi_n (k) = \perp$. Contradiction.\\ 
\underline{Si ce n'est pas le cas}: alors $f(k) = m$. Donc $\varphi_k (k) = \varphi_m (k)$. $\varphi_k (k) = \perp$ car n'appartient pas à l'ensemble et $\varphi_m (k)$ est constant $k$. Contradiction.

\subsection{Théorème de Rice via théorème du point fixe}
Si $A \neq \varnothing$ et $A \neq \mathbb{N}$ et $\forall i \in A$, $\forall j \in \overline{A}$ qui $\varphi_i \neq \varphi_j$ donc $A$ est non récursif.

\subsubsection{Démonstration}
Comme on a $A \neq \varnothing : n \in A$ et $A \neq \mathbb{N}: m \in \overline{A}$. On définit:
\begin{align*}
f(x) &= m \text{ si } x \in A\\
&= n \text{ si } x \in \overline{A}
\end{align*}
Cette fonction $f$ est totale calculable si $A$ est récursif !\\
En appliquant le point fixe: $\exists k : \varphi_k = \varphi_{f(k)}$. Mais $k \in A$ ?\\
\underline{Si c'est le cas}: alors $f(k) = m$ alors $\varphi_k = \varphi_m$ donc $k \in \overline{A}$ par définition. En effet $m \in \overline{A}$ et grâce à l'hypothèse du théorème de \textbf{Rice}. \\
\underline{Si ce n'est pas le cas}: alors $f(k) = n$ alors $\varphi_k = \varphi_n$ donc $k \in A$ par définition. En effet $n \in A$ et grâce au théorème de \textbf{Rice}.\\
Donc $A$ est \textbf{non récursif} !

\subsection{Analyse}
C'est un théorème important et central. Il utilise \textbf{uniquement} la propriété $S$ des langages de programmation. Il implique:
\begin{enumerate}
\item Théorème de Rice.
\item La non récursivité de $K$.
\item Implie la non calculabilité de fonction $HALT$.
\end{enumerate}

\section{Démonstration du théorème du point fixe}
On va faire la technique des $3$ lapins. Si on a une fonction $f$ qui est totale calculable, on veut montrer que $\exists k: \varphi_k = \varphi_{f(k)}$.
\subsubsection{Lapin 1}
\begin{equation}
h(u,x) = \begin{cases}
\varphi_{\varphi_u (u)}(x) \text{ si } \varphi_u (u) \neq \perp \\
\perp \text{ sinon}
\end{cases}
\label{Lapin1}
\end{equation}
Cette fonction $h$ est calculable. On va d'abord exécuter $\varphi_u (u)$ puis on essaye de faire l'autre $\varphi$ sinon $\perp$.

\subsubsection{Lapin 2}
\begin{equation}
h(u,x) = \varphi_{g(u)} (x)
\label{Lapin2}
\end{equation}
On va appliquer la propriété S. $g$ existe et est totale calculable.

\subsubsection{Lapin 3}
\begin{equation}
t(x) = f(g(x))
\end{equation}
$t$ est totale calculable car $g$ l'est et $f$ de mon hypothèse l'est. Ainsi, on a un \textbf{numéro de programme} $k'$.
\begin{equation}
\exists k' : t(x) = \varphi_{k'}(x) = f(g(x))
\label{Lapin3}
\end{equation} 

\subsubsection{Fin du tour de magie}
\begin{align*}
\forall x : h(k',x) &= \varphi_{g(k')} (x) \text{ via Lapin 2 (\ref{Lapin2})}\\
\cline{1-2}
\forall x h(k', x) &= \varphi_{\varphi_{k'} (k')} (x) \text{ via Lapin 1 (\ref{Lapin1})}\\
&= \varphi_{f(g(k'))} (x) \text{ via Lapin 3  (\ref{Lapin3})}
\end{align*}
Si je pose que $k = g(k')$ alors $\forall x : \varphi_k (x) =  \varphi_{f(k)} (x)$.

\section{Autres problèmes non calculables}
\subsubsection{Liste équivalente de mot}
Si on a 2 listes comme ci-dessous, il n'existe \textbf{aucun} algorithme qui nous permettent de trouver une suite d'indice qui produit 2 mots équivalents depuis deux listes. C'est donc un problème \textbf{non calculable}.
\begin{lstlisting}[escapechar=\%]
%$\Sigma$% = {a,b} 
U = {u1=b, u2=babbb, u3=ba}
V = { v1=bbb, v2=ba, v3=a}
Res = {2 1 1 3} //%car U: babbb, b, b, ba et V: ba, bbb,bbb, a%
\end{lstlisting}

\subsubsection{Équations diophantiennes}
C'est une équation de la forme: $D(x_1, ..., x_n) = 0$. L'équation ne possède que des \textit{coefficients entiers} et on cherche des solutions \textit{entières}.\\
C'est bel et bien un problème \textbf{non calculable}.
\begin{align*}
P(a) \leftrightarrow \exists x_1, ..., x_n [D(a,x_1, ..., x_n) = 0]
\end{align*}
Ci-dessus, c'est la condition pour être diophantien pour une fonction.

\section{Codage et représentation}
Jusqu'ici, on avait des fonctions $N^n \rightarrow N$ et on avait des représentations décimales des nombres. Mais on ne prend pas en compte les autres types de donnés, ... Donc on va créer des fonctions de codage et représentation.

\subsubsection{Codage}
On va définir une bijection entre notre nouveau type et les entiers. On peut identifier chaque objet par un entier \textit{distinct}. Ce qui nous amène à une propriété très utile:
\begin{enumerate}
\item la fonction de codage est bijective
\item la fonction de codage est calculable
\item la fonction de codage inverse est calculable
\end{enumerate}

\subsection{Les nombres calculables}
On sait que tout nombre réel est fini tout comme la limite d'une suite \textit{convergente} vers un rationnel $\mathbb{Q}$ Donc:
\begin{align*}
\forall x \in \mathbb{R}, \exists s &: N \rightarrow Q : \text{ (s est total)}\\
lim_{n\rightarrow \infty} &| x - s(n)| = 0
\end{align*}

\subsubsection{Définition}
On dit qu'un réel $x$ est \textbf{calculable} si il existe une \textcolor{red}{fonction totale calculable}:
\begin{align*}
s: N \rightarrow Q\\
\forall n: |x-s(n)| \leq 2^{-n}
\end{align*}
Donc notre fonction ne fait que s'approcher autant qu'on veut de notre réel.

\subsubsection{Propriétés}
Donc un $\mathbb{R}$ est calculable s'il existe un programme qui le calcule. Ce qui par induction rend l'ensemble des nombres calculables énumérables.\\
Il existe des réels donc non-calculables mais qui peuvent être définie de manière finie comme:
\begin{align*}
x = \sum_{0 \geq n \geq \infty} \chi_K (n) 3^{-n}
\end{align*}


\chapter{Modèles de calculabilité}

\section{Familles de modèles}
\noindent 
Il existe \textcolor{red}{2} familles de modèles:
\begin{enumerate}
\item Basé sur le \textcolor{red}{calcul}
\item Basé sur le \textcolor{red}{langage} (chaine de caractère)
\end{enumerate}

\subsection{Basé sur le calcul}
Leur objectif est de modéliser le concept de fonctions calculables, processus de calcul, algorithme effectif, ... Ex
\begin{itemize}
\item Automate fini
\item Machine de Turing
\item Langages de programmation
\end{itemize}
Il existe 2 sous-catégories:
\begin{enumerate}
\item Modèles \textcolor{blue}{déterministes}: il n'y a qu'un seule exécution possible d'un programme pour un input donné.
\item Modèles \textcolor{blue}{non déterministes}: il existe plusieurs exécutions possibles pour un input donné.
\end{enumerate}

\subsection{Langes de programmation}
C'est le modèle basé sur le \textcolor{red}{calcul} qui est un exemple de la \textbf{calculabilité} qui est le plus \textit{courant}. (on l'a utilisé pour démontrer toutes les théories fondamentales de la \textit{calculabilité})

\subsubsection{Définir un langage}
\noindent
On doit définir la:
\begin{enumerate}
\item Syntaxe du langage
\item Sémantique du langage
\item Convention de représentation d'une fonction par un programme
\end{enumerate}

\subsubsection{Équivalence des programmes}
On sait que les langages de programmation sont \textcolor{blue}{équivalents} entre eux.  Une fonction est calculable en \textit{Rust} alors elle le sera en \textit{C}. On dit que les langages sont \textcolor{red}{Complets}.\\
Bien évidemment, certains problèmes sont plus simples et/ou plus efficace à résoudre dans un langage de programmation spécifique.\\

\subsubsection{BLOOP}
BLOOP ou \textit{Bounded loop} qui est Java sans les boucles while, on ne modifie pas la variable de \textit{compteur} dans le corps d'un \textit{for}. Pas de méthodes récursives ni mutuellement récursibles.\\
Donc \textcolor{blue}{BLOOP} se termine toujours et ne calcule que des fonctions \textit{totales}. Cependant, il ne calcule pas \textcolor{red}{toutes les fonctions totales} (voir \ref{HA}). En effet, l'interpreteur n'est pas programmable en BLOOP. Donc ce \textbf{n'est pas} un modèle complet de la calculabilité.

\subsection{Non-déterministe}
On va créer \textcolor{blue}{ND-Java} qui est une version \textit{non-déterministe} de Java. On lui ajoute la fonction \textbf{choose(n)} qui renvoie un entier entre \textbf{0 et n} et est donc non déterministe.\\
On doit considérer n+1 exécution possible à chaque lancement de la fonction. \\
Donc pour le problème du voyageur de commerce, on va énumérer tous les chemins possibles en swapant un à un les villes. Donc on aura un arbre de décision. Ainsi, on peut regarder la profondeur du chemin pour savoir si le nombre de possibilité est borné.\\
Il y aura des chemins où ce sera borné et des chemins où ça ne l'est pas.\\
On dit qu'un programme nous produit une \textcolor{blue}{relation} plutôt qu'une fonction.

\subsubsection{Récursif ND}
On dit qu'un ensemble A ($A \in \mathbb{N}$) est \textcolor{red}{ND-récursif} si il existe un programme \textbf{ND-Java} tel que lorsqu'il reçoit comme donnée n'importe quel nombre naturel $x$.
\begin{itemize}
\item si $x \in A$, alors il existe un \textcolor{blue}{exécution} fournissant comme résultat 1 (peu importe le temps)
\item si $x \notin A$ alors \textbf{toutes} les \textcolor{blue}{exécutions} possibles fournissent comme résultat 0.
\end{itemize}

\subsubsection{ND Récursivement énumérable}
On dit que A est \textcolor{red}{ND-récursivement énumérable} si il existe un programme ND-Java tel que lorsqu'il reçoit comme donnée n'importe quel nombre naturel x, il existe une \textcolor{blue}{exécution} fournissant comme résultat 1 \textbf{ssi $x \in A$}. (Si $x \notin A$ alors la fonction retourne autre chose que $1$ ou est $\perp$)

\subsubsection{Propriétés}
Un ensemble est \textbf{ND-récursif} ssi il est \textbf{récursif}. Si nous avons un arbre d'exécutions possibles, il est toujours possible de parcourir tous les \textbf{étages} de notre arbre et donc parcourir toutes les exécutions \textcolor{blue}{possibles} comme si on était en "\textit{déterministe}".\\
Si la profondeur d'une branche est de taille $n$, alors mon parcours a une complexité exponentielle tel que $b^n$.

\subsection{Basé sur le langage}

Se base sur un ensemble de mot et possède une \textcolor{blue}{grammaire formelle}. On essaye de modéliser une classe de langages. Le langage est donc un ensemble \textit{récursif} ou \textit{récursivement énumérable}. Pas vu dans ce cours

\section{Automates finis}
\noindent
C'est une modélisation assez simple du concept de \textit{calcul}, il y a:
\begin{itemize}
\item Un nombre \textit{fini d'états}
\item Une lecture d'une donnée: un mot
\item Chaque symbole de la donnée est lu \textit{une et une seule} fois
\item On transitionne d'état en état en fonction du \textit{symbole lu}.
\item L'état final est l'état après avoir \textit{lu tous les symboles} de la donnée
\item On \textbf{ne peut pas} mémoriser quelque chose. 
\end{itemize}
Donc l'objectif d'un \textcolor{blue}{automate fini} est de \textbf{décider} si un mot appartient à un langage. Réponse binaire: Oui ou Non. \textbf{Pas de boucle}.
\subsubsection{Modèle}
\noindent
On a un:
\begin{itemize}
\item $\sum$ qui est l'ensemble (\textit{fini}) de symboles
\item $S$ qui est l'ensemble (\textit{fini}) d'états
\item $s_0 \in S$ qui est l'état initial
\item $A \subseteq S$ qui est un ensemble d'état acceptant
\item $ \delta  S  \Sigma \rightarrow S $ qui est une fonction de \textit{transition}. (C'est une sorte de tableau)
\end{itemize}
C'est donc un modèle de calcul. On parcourt le mot symbole par symbole et on termine notre exécution à la fin de la lecture de symbole. Pour simplifier tout cela, on va rajouter un état \textit{fail} si on n'a pas tout déterminé pour les multiples possibilités.\\

Un état acceptant est représenté par un \textbf{double cercle} et un état non-acceptant est représenté par un \textbf{simple cercle}. Les flèches ou les \textit{arcs} sont les \textcolor{blue}{fonction de transition}.\\

Un mot est accepté si l'état final de ce mot est dans l'état \textit{acceptant}. (et vice-versa)\\
Dans un automate fini, son exécution se finit \textbf{toujours}! Donc cela ne détermine que des ensembles \textcolor{blue}{récursifs} (mais pas tous les ensembles récursifs (\ref{HA}))\\
Il est aussi important de remarquer que si on ne possède pas de transition à un état, on échoue et l'automate échoue !

\subsection{Extension}
On peut étendre les automates aux \textcolor{blue}{automates finis non déterministes}. On a donc plusieurs transitions possibles pour une paire. Plusieurs exécutions pour une même donnée.\\
Un mot m est accepté par \textit{NFDA} si il existe \textbf{une} exécution de NFDA, où on finit dans un état acceptant.\\
Pour toute exécution de NFDA, un mot \textbf{n'est pas accepté} s'il ne tombe jamais sur un état acceptant.\\

On peut voir comme si on rassemblait des exécutions ensemble et des ensemble d'états.

\subsubsection{Avec transitions vides}
On peut faire des transitions sans \textbf{rien} consommer via le symbole $+-\varepsilon$. N'apporte pas de puissances en plus juste un passage sans consommer.

\subsubsection{Interprétation}
On peut voir ça comme le travail d'un compilateur qui fait une \textcolor{blue}{analyse lexical} via un découpage de \textit{tokens}.\\
On peut faire de la recherche de paterne (regex). Donc utile dans un éditeur de texte.\\
Un automate fini est également utile pour les \textit{interfaces utilisateurs}. Cela se comporte toujours de la même manière peu importe ce qu'il s'est passé auparavant.

\section{Machines de Turing}
C'est une idée inventée par \textit{Alan Turing} en 1936 qui est antérieur aux ordinateurs. C'est un modèle très \textit{simple} mais qui est le plus \textit{puissant} possible.

\subsection{Fonctionnement}
On dispose d'un \textcolor{blue}{ruban} qui est infini à \textit{droite} et à \textit{gauche}. On a une \textit{tête de lecture} qui peut lire et écrire un caractère à l'endroit qu'elle pointe sur le ruban.\\
Il y a également un mécanisme de \textit{contrôle} qui gère les actions à l'exécution.

\subsubsection{Contrôle}
On a un ensemble fini d'états: soit en \textit{état initial} ou un \textit{état d'arrêt}. Le contrôle contient un programme et un \textit{mécanisme} qui exécute les instructions.\\
Les formes d'instructions sont comme:
\begin{align*}
<q, c> \rightarrow <q_{new}, Mouv, c_{new}>
\end{align*}
\begin{itemize}
\item $q$: état courant.
\item $c$: caractère sous la tête de lecture.
\item $c_{new}$: caractère à écrire.
\item $Mouv$: mouvement vers la \textit{gauche} ou la \textit{droite} de la tête de lecture à effectuer.
\item $q_{new}$: état suivant après instruction.
\end{itemize}

\subsection{Modélisation Formelle}
\noindent
Une machine de Turing est composée de:
\begin{itemize}
\item $\sum$: ensemble fini de symboles d'entrée
\item $\Gamma$: ensemble fini de symboles du ruban donc
\begin{enumerate}
	\item $\sum \subset \Gamma$
	\item $B \in \Gamma, B \notin \sum$(symbole blanc) Contenu implicite de toutes les cases du ruban sauf de l'input.
\end{enumerate}
\item $S$: ensemble fini d'états
\item $s_0 \in S$: état initial
\item $stop \in S$: état d'arrêt
\item $ \delta  S  \Gamma \rightarrow S  $ \{G,D\} $ \Gamma $ : fonction de transition (\textit{fini})
\end{itemize}
%Problème avec le \time

\subsubsection{Exécution}
Au début, on a des données sur le ruban et le reste est rempli du symbole \textcolor{blue}{blanc}. L'état initial de la tête est sur le premier caractère du ruban.\\
Le résultat est le contenu sur le ruban à l'état stop.
\begin{figure}[H]
\centering
\includegraphics[width=8cm]{img/turing.png}
\caption{Tableau d'exécution pour l'addition binaire}
\end{figure}

On peut boucler en machine de Turing, par exemple on ne fait qu'aller vers la droite. Donc la machine de Turing est complet.

\subsection{Fonction T-calculables}
Une fonction f est \textcolor{red}{T-calculable} si et seulement si il existe une machine de Turing qui, recevant comme donnée (\textit{une représentation décimale de}) n'importe quel nombre naturel x, nous fournit comme résultat $f(x)$ si il est \textcolor{red}{défini}. Et ne se termine pas si $\textcolor{red}{f(x) = \perp}$\\
On peut également étendre cela aux fonctions $\mathbb{N}^n \rightarrow n$. Ce sont des définitions proche de l'idée de la calculabilité pour \textit{Java}.

\subsection{Thèse de Church-Turing}
\begin{enumerate}
\item Toute fonction T-calculable est calculable
\item Toute fonction calculable est T-calculable
\item Tout ensemble T-récursif est récursif
\item Tout ensemble récursif est T-récursif
\item Tout ensemble T-récursivement énumérable est récursivement énumérable
\item Tout ensemble récursivement énumérable est T-récursivement énumérable
\end{enumerate}
Le but de ces machines de \textit{Turing} est d'être à l'essentielle. On est à l'essence même des principes de calculabilité. De plus, la complexité est plutôt simple via le concept de transition.

\subsection{Extensions des Machines de Turing}
On va donc modifier le modèle de base des machines de Turing. Mais est-ce plus \textit{puissant} (peut calculer plus de fonctions) et plus \textit{efficace} (moins d'étape à réaliser).

\subsubsection{Changement de convention}
On peut maintenant faire bouger la tête de \textcolor{blue}{plusieurs} cases et on a plusieurs états \textcolor{blue}{stop}. On a donc la même puissance mais une accélération du processus.\\
On peut aussi limiter l'alphabet en ayant un alphabet \textcolor{blue}{binaire}. Toujours même puissance et efficacité. Mais cela va \textit{limiter} le nombre d'état possible donc va enfaite limiter la machine.\\

On peut aussi imaginer un ruban \textcolor{blue}{uni-directionnel} donc aller que vers la gauche. Toute machine de Turing peut être ré-exprimer dans ce type de machine. On perd en puissance et ralentissement linéaire.\\
On peut avoir un ruban multi case. Donc même puissance et même efficacité.\\

On peut avoir plusieurs rubans avec chacun ayant sa propre tête de lecture. Donc chaque tête est indépendante (\textit{thread}). On aura toujours la même puissance mais une accélération quasi quadratique.\\
Ou bien avec plusieurs tête, même résultat que précédemment.

\subsubsection{Turing non-déterministe}
On peut imaginer des relations au lieu de transitions. Via ce système, on sait déterminer si un élément appartient à un ensemble ou non.
\begin{align*}
\Delta \subseteq S \Gamma S \{G,D\} \Gamma
\end{align*}
Il y a donc plusieurs exécutions possibles.\\
Si $A \subset \mathbb{N}$, A est NDT-récursif si il existe une ND-machine de Turing telle que lorsqu’elle reçoit comme donnée n’importe quel nombre naturel $x$. Si $x \in A$ alors il \textcolor{blue}{existe une exécution} qui fournit un résultat $=1$. Ou bien \textcolor{blue}{toutes les exécutions} possibles fournissent $0$.\\

$A$ est \textit{NDT-récursivement énumérable} si il existe une ND-machine de Turing telle que lorsqu'elle reçoit comme donnée n'importe quel nombre naturel x, il existe une exécution fournissant $1$ si $x \in A$ et un résultat différent de $1$ sinon.\\

Cela a la même puissance qu'une machine de Turing. Donc on peut toujours créer une machine de ND-Turing qui est équivalent à une machine de Turing et vice versa.\\
Une ND-machine de Turing peut accélérer de manière exponentielle $b^n$ où $b$ est le facteur de branchement. \textcolor{red}{Attention}, ce \textit{speedup} ne peut pas être utilisé car aucune machine peut avoir un parallélisme infini !

\subsubsection{3 états spéciaux}
Il existe la Machine avec \textcolor{blue}{oracle}:
\begin{enumerate}
\item $oracle_{ask}$: on demande si l'entier \textit{représenté} à droite de la tête de lecture appartient à l'ensemble $A$.
\item $oracle_{yes}$: l'entier appartient à $A$
\item $oracle_{no}$: l'entier n'appartient pas à $A$
\end{enumerate}
Donc, l'état suivant n'est pas spécifié dans l'instruction. Le nouvel état sera $oracle_{yes}$ ou $oracle_{no}$\\
En terme de puissance, on est équivalent \textbf{si} $A$ est récursif. Si ce n'est \textbf{pas récursif} alors mon modèle est \textit{plus puissant} que la machine de Turing. Je peux programmer la fonction \textit{HALT}. (c'est bien évidemment un modèle abstrait).\\


C'est pour voir les possibilités. On peut établir les indécidables.

\subsubsection{Machine de Turing universelle}
On veut établir une machine de Turing qui soit un interpréteur de machines de Turing. On peut arriver à cela juste en utilisant les symboles $\{0, 1\}$. Bien évidemment, cette machine est \textit{extrêmement} complexe. L'ensemble des codes de machine de Turing est un ensemble récursif.\\

On peut construire l'interpréteur avec 3 rubans:
\begin{enumerate}
\item : codage de la machine de Turing interpréteur
\item : les données
\item : résultat intermédiaire de l'interpréteur
\end{enumerate}
On utilise donc \ref{HA}, $\exists z \forall n , x : \varphi_z(n,x) = \varphi_n(x)$. $\varphi_n(x)$ est la fonction calculée par la machine de Turing de code n et $\varphi_z$ la fonction universelle calculable. $MT_z$ est le programme universel (\textit{interpréteur})\\

\subsubsection{L'arrêt}
On peut démontrer, en utilisant le modèle des machine de Turing que le problème de l’arrêt est non calculable. Même méthode de démonstration, mais adaptée aux machines de Turing. La preuve a été faite avec des machines de Turing pour la première fois.


\chapter{Logique}
\section{Logique des propositions}
On va décrire la syntaxe des formules logiques.\\
Son but premier est de:
\begin{itemize}
\item Représenter des connaissances
\item Raisonner de manière automatique sur ces connaissances
\end{itemize}
Il existe la logique de \textbf{propositions}, des \textbf{prédicats}, \textbf{temporelle}, \textbf{floue}, \textbf{modale}, ...

\subsection{Composition de la logique de propositions}
\begin{center}
\begin{tabular}{|m {3cm}| m {5cm}| m{5cm}|}
\hline
Type & Description \\
\hline
Syntaxe & On détermine la structure accepté dans un langage \\
\hline
Sémantique & On leur donne un sens à ces formules \\
\hline
Raisonnement & On propose une méthode pour manipuler les formules et obtenir des informations pertinentes \\
\hline
\end{tabular}
\end{center}

\subsection{Description}
C'est la logique "\textit{la plus simple}" et la plus ancienne.\\
On se base sur le principe de proposition. Ce sont des affirmations qui sont vraies ou fausses. (ex: \textit{le soleil brille}, \textit{le sommet $V_2$ du graphe a la couleur rouge}, ...)\\

On représente ces affirmations par une \textbf{suite de caractères} qu'on peut appeler \textit{variable propositionnelle}\\
On lie ces variables via des \textcolor{blue}{connecteur logique} (ET, OU, ...)

\subsubsection{Symboles}
\begin{itemize}
\item \textit{Constante}: True et False.
\item \textit{Variables propositionnelles}: nos chaines de caractères.
\item \textit{Connecteur logique}: ne pas $\neg$, conjonction $\wedge$, disjonction $\vee$, implication $\Rightarrow$ et équivalence $\Leftrightarrow$
\item \textit{Parenthèses}
\end{itemize}

\subsubsection{Formules propositionnelles}
Une \textit{constante logique} et une \textit{variable propositionnelle} sont toutes les deux des formules propositionnelles. On peut donc combiner des formules propositionnelles pour en créer de \textcolor{blue}{nouvelle}.

\subsection{Convention}
On supprime les parenthèses les plus extérieures pour essayer de réduire le nombre de parenthèse.\\
La \textcolor{red}{précédences des opérateurs} est importante et permet de supprimer des parenthèses: 1. $\neg$ 2. $\wedge$ 3. $\vee$ 4. $\Rightarrow$ 5. $\Leftrightarrow$\\
On a un ordre d'\textcolor{red}{associativité} qui définisse l'ordre de deux connecteurs identiques successifs. $\wedge$ et $\vee$ sont associatifs à \textcolor{blue}{gauche} et $\Rightarrow$ et $\Leftrightarrow$ sont associatifs à \textcolor{red}{droite}.

\subsubsection{Exemple}
\begin{center}
\begin{tabular}{|cc|cc|cc|}
\hline
$A \wedge B$ & $(A \wedge B)$ & $\neg A \wedge B$ & $((\neg A) \wedge B)$ & $A \wedge \neg B$ &  $(A \wedge (\neg B))$\\
\hline
$A \vee B \vee C$ & $((A \vee B) \vee C)$ & $A \Rightarrow B \vee C$ & $(A \Rightarrow ( B \vee C))$ & $A \Rightarrow B \Rightarrow C$ &  $(A \Rightarrow ( B \Rightarrow C))$\\
\hline
\end{tabular}
\end{center}

\section{Sémantique}
Correspond à la signification d'une formule propositionnelles. Le sens d'une formule dépend d'un \textit{contexte} donc des valeurs propositionnelles.\\
On appelle ce \textit{contexte} une \textcolor{red}{interprétation}. Une interprétation d'une formule est une \textit{assignation} d'une valeur de vérité (\textit{true ou false}) à chacune des variables propositionnelles de la formules.\\
Donc si on a $n$ variables, il y a donc $2^n$ interprétations possibles.

\subsection{Valeur de vérité}
Selon une interprétation I, on dérive la \textit{valeur de vérité d'une formule} selon les règles suivantes:
\begin{itemize}
\item La valeur de vérité des constantes True et False sont respectivement \textit{true} et \textit{false}
\item La valeur de vérité d'une variable propositionnelle A est la valeur de cette variable dans l'interprétation I.
\end{itemize}
\begin{center}
\begin{tabular}{|c|c||c|c|c|c|c|}
\hline
\cellcolor[gray]{0.8} \textcolor{blue}{$p$} & \cellcolor[gray]{0.8} \textcolor{blue}{$q$} & \cellcolor[gray]{0.8} \textcolor{red}{$\neg p$} & \cellcolor[gray]{0.8} \textcolor{red}{$p \wedge q$} & \cellcolor[gray]{0.8} \textcolor{red}{$p \vee q$} & \cellcolor[gray]{0.8} \textcolor{red}{$p \Rightarrow q$} &\cellcolor[gray]{0.8} \textcolor{red}{$p \Leftrightarrow q$}\\
\hline
true & true & false & true & true & true & true \\
\hline
true & false & false & false & true & false & false \\
\hline
false & true & true & false & true & true & false \\
\hline
false & false & true & false & false & true & true \\
\hline
\end{tabular}
\end{center}

\subsection{Modèle}
C'est une interprétation dont la formule est vrai.\\
Le sens d'une formule propositionnelle, donc sa sémantique, est défini par les différents modèles de cette formule.\\
Donc elle est défini par \textbf{tous les modèles de cette formule}. La signification d'une formule propositionnelle est déterminée par l'ensemble de ses modèles.

\subsection{Formules équivalentes}
Deux formules (composés des mêmes variables propositionnelles) sont donc équivalentes si elles ont les mêmes modèles.\\
Une \textit{sous-formule} peut toujours être remplacée par une \textit{sous-formule} \textcolor{blue}{équivalente} sans forcément changer sa \textit{sémantique}.
\begin{center} \label{equi}
\begin{tabular}{|cc|cc|cc|}
\hline
$\neg (\neg p)$ & $p$ & $p \wedge q$ & $q \wedge p$ & $p \vee q$ &  $q \vee p$\\
\hline
$p \Leftrightarrow q$ & $(p \Rightarrow q) \wedge (q \Rightarrow p)$ & $p \Rightarrow q$ & $\neg p \vee q$ & $p \Rightarrow q$ &  $\neg p \Rightarrow \neg q$\\
\hline
$\neg ( p \vee q) $ & $\neg p \wedge \neg q$ & $\neg ( p \wedge q )$ & $\neg p \vee \neg q$ & $p \vee (q \wedge r)$ &  $(p \vee q ) \wedge ( p \vee r)$\\
\hline
 & & $p \wedge ( q \vee r)$ & $(p \wedge q) \vee (p \wedge r)$ & & \\
\hline
\end{tabular}
\end{center}
On va s'intéresser à \textcolor{blue}{l'équivalence de Morgan} qui $\neg(p \wedge q) \rightarrow \neg p \vee \neg q$

\subsubsection{Démonstration de Morgan}
On commence par dénombrer le nombre de possibilités: on a 2 variables donc $2^2 = 4$ possibilités
\begin{center}
\begin{tabular}{|c|c||c|c|}
\hline
\cellcolor[gray]{0.8} p & \cellcolor[gray]{0.8} q & \cellcolor[gray]{0.8} $\neg( p \wedge q)$ &\cellcolor[gray]{0.8} $\neg p \vee \neg q$\\
\hline
true & true & false & false\\
true & false & true & true \\
false & true & true & true\\
false & false & true & true\\
\hline
\end{tabular}
\end{center}

\section{Ensemble SAT}
L'ensemble des formules \textbf{Satisfaisable}. On veut être en mesure d'effectuer des raisonnements sur différentes formules.\\
Mais, on a le \textcolor{red}{problème de la satisfiabilité} comment savoir si une formule F a un modèle. Le modèle est une "\textit{solution}" qui rend cette formule F vraie.\\

Et en \textcolor{red}{conséquence logique}, si on a notre formule F, quelles sont les conséquences de F.\\
Quelles formules sont-elles vraies si F l'est.

\subsection{Satisfiabilité}
Une formule propositionnelle est \textcolor{red}{satisfaisable} si elle possède au moins un modèle. Si elle n'en possède \textbf{aucun} alors elle est \textcolor{red}{non satisfaisable}, on appelle cela une contradiction.\\
L'ensemble SAT est donc l'ensemble des formules propositionnelles satisfaisables
\subsubsection{Valeur de vérité}
Étant donné une interprétation et une formule propositionnelle, sa valeur de vérité peut être déterminée par un \textit{algorithme}.\\
Pour une formule avec $n$ variables propositionnelles, il existe donc $2^n$ interprétations possibles.\\
L'ensemble \textbf{SAT} est donc récursif.\\
exemple de formules non satisfaisables: $(A \vee B) \wedge (A \vee \neg B) \wedge (\neg A \vee B) \wedge ( \neg A \vee \neg B \vee \neg C) \wedge ( \neg A \vee C)$

\subsubsection{Tautologie}
C'est une formule qui est toujours vraie dans toutes les interprétations. ex: $A \vee \neg A$.\\
$p$ est donc une tautologie si et seulement si $\neg p$ est \textbf{non satisfaisables}.

\subsection{Conséquence logique}
La formule $q$ est une \textcolor{red}{conséquence logique} d'une formule $p$ si la formule $p \Rightarrow q$ est une \textit{tautologie}.\\
\begin{enumerate}
\item Donc tous les modèles de $p$ sont aussi des modèles de $q$.
\item La formule $q$ est vraie dans tous les modèles de $p$.
\end{enumerate}
On note cela: $p \models q$

\subsubsection{propriété}
\noindent
$p \models q$ ssi $(p \wedge \neg q)$ est \textit{non satisfaisable}\\
Preuve: $p \models q$ ssi:
\begin{itemize}
\item $p \Rightarrow q$ est une tautologie
\item $\neg( p \Rightarrow q)$ est non satisfaisable
\item $\neg(\neg p \vee q)$ est non satisfaisable
\item $(\neg \neg p \wedge q)$ est non satisfaisable
\item $( p \wedge \neg q)$ est non satisfaisable
\end{itemize}
Attention: si q n'est pas une conséquence logique de p, on n'a pas nécessairement que $\neg q$ est une conséquence logique de p.\\
On peut avoir $p \nvDash q$ et $p \nvDash \neg q$. Donc $p \Rightarrow q$ et $p \Rightarrow \neg q$ ne sont pas des tautologies. ex:$(A \vee B) \nvDash A$ et $(A \vee B)) \nvDash \neg A$

\section{Modélisation}
Problème: on veut colorier les noeuds d'un graphe de manière à ce que deux noeuds adjacents aient des couleurs différentes.
\subsection{Formalisme}
On un graphe $G=(V,E)$ où V est l'ensemble des noeuds et E les arrêtes. On a un ensemble $C$ de couleurs.\\
On définit les variables propositionnelles suivantes:
\begin{itemize}
\item couleur $[v,c]$ (distinct) avec $v \in V$ et $c \in C$
\item La variable de couleur $[v,c]$ est vraie si le noeud $v$ est de couleur $c$. Faux sinon.
\item Il y a donc $\# V \times \# C$ variables propositionnelles distinctes.
\end{itemize}

\subsubsection{Représentation}
Notre modèle est composée d'une \textbf{conjonction de formules}.
\begin{itemize}
\item Pour chaque arrête $(v,w) \in E$ on impose que les deux noeuds n'aient pas la même couleur via: $\neg(\text{couleur}[v,c]\wedge \text{couleur}[w,c])$
\item Pour chaque noeuds $v \in V$, la disjonction des couleurs $ [v,c] $ sur toutes les couleurs $c \in C$ nous assure que chaque noeud a au moins une couleur
\item Pour chaque noeud $v \in V$ la conjonction va s'assurer que chaque noeud n'a pas plus d'une couleur: $\neg ( \text{couleur}[v, c_1] \wedge \text{couleur}[v, c_2])$ on utilise des paires de couleurs $ [c_1, c_2] $
\end{itemize}

\subsubsection{Affirmation}
Si j'ai un modèle pour une conjonction de formule, j'ai donc une solution (le modèle) pour ce problème.\\
Si la formule n'est pas satisfaisable alors il n'existe pas de solutions pour ce problème.\\
Donc comment savoir si le problème est faisable ? Voir si notre formule est \textbf{satisfaisable}. Si elle l'est, on peut retourner le modèle.


\section{Raisonnement}
Lorsqu'on veut raisonner, il se pose à nous deux problèmes:
\begin{enumerate}
\item $p \models q$ Une formule $q$ est-elle une \textcolor{blue}{conséquence logique} d'une formule $p$
\item $p \in SAT$ donc existe-t-il au moins 1 modèle pour cette formule $p$
\end{enumerate}
On peut réduire le 1. au 2. via: $p \models q \text{ ssi } (p \wedge \neg q) \notin SAT$\\

On peut utiliser des \textit{solveurs SAT} qui sont des algorithmes de décision pour SAT.\\
Ou bien, on peut utiliser l'\textit{inférence} qui est une méthode formelle utilisant des règles d'inférences.

\subsection{Solveur SAT}
C'est un modèle élémentaire basé sur le \textbf{model checking}. Il prend en \textit{input} une formule $p$ qui a $n$ variables propositionnelles.\\
L'algorithme consiste à énumérer parmi les $2^n$ interprétations possibles pour p.\\
Si $p$ est vraie pour une interprétation, on retourne $<true,I> (p\in SAT)$(I étant l'interprétation)\\
Si on ne trouve aucune interprétation correcte, on retourne $<false, \varnothing> (p \in SAT)$\\

\subsubsection{Solveur efficace}
Ce type de solveur travaille sur une forme simplifiée des formules propositionnelles: \textcolor{red}{les formules sous forme normale conjonctive} (CNF):
\begin{itemize}
\item Négation uniquement devant une \textit{variable propositionnelle}
\item Que des disjonctions et des conjonctions
\item La formule est une suite de conjonctions dont chaque élément est une disjonction de variables ou de négation de variables.
\end{itemize}
ex: $(\neg A \vee \neg C) \wedge ( \neg A \vee D) \wedge (\neg B \vee \neg C) \wedge (\neg B \vee D) \wedge (A \vee B \vee C \vee \neg D)$ Donc entre chaque conjonction, on a des disjonctions de variables.\\
Nomenclature:
\begin{itemize}
\item \textit{Literal}: est une variable propositionnelle $A$ ou sa négation $\neg A$
\item \textit{Clause}: est une disjcontion de littéraux
\item \textit{CNF}: est une conjonction de \textit{clauses} $c_1 \wedge ... \wedge c_n$
\item \textit{Formule CNF}: on représente une telle formule comme: $\{c_1, ..., c_n \}$
\end{itemize}

\subsubsection{Transformation en CNF}
On peut toujours représenter une formule sous forme \textit{CNF}. il faut suivre ces étapes:
\begin{enumerate}
\item Éliminer les $\Leftrightarrow$ et $\Rightarrow$ en utilisant les équivalences (voir \ref{equi})
\item Mettre les symboles de négation dans des littéraux en utilisant la double négation et les équivalences de Morgan
\item Utiliser la distributivité sur $\wedge$ et $\vee$
\end{enumerate}
\begin{align*}
\text{Exemple:} (A \vee B) &\Leftrightarrow (\neg C \wedge D) & (\neg(A \vee B) \vee ( \neg C \wedge D)) &\wedge (\neg (\neg C \wedge D) \vee ( A \vee B))\\
((\neg A \wedge \neg B) \vee ( \neg C \wedge D )) &\wedge ( C \vee \neg D \vee A \vee B) & (\neg A \vee \neg C) \wedge ( \neg A \vee D ) \wedge ( \neg B \vee \neg C) &\wedge (\neg B \vee D) \wedge (A \vee B \vee C \vee \neg D)
\end{align*}

\subsection{Résolution}
On transforme la formule propositionnelle en appliquant des règles de transformations successives.\\
On réalise des règles d'inférence à chaque étape et on garantit que chaque formule résultante est équivalente à la formule initiale.

\subsubsection{Exemple de règles}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Nom & prémices & prémices & conclusion\\
\hline
Équivalence & $p \Leftrightarrow q$ & $q \Leftrightarrow r$ & $p \Leftrightarrow r$\\
\hline
Modus ponens & $p \Rightarrow q$ & $p$ & $q$\\
\hline
\end{tabular}
\end{center}
Si on a un ensemble de formules propositionnelles $F$ qui représentante une Formules. Si on a des prémices qui appartiennent à cet ensemble, on peut ajouter des conclusions pour en faire $F'$ et dire que $F = F'$


\subsubsection{Résolution}
Les règles d'inférence unique généralisant le \textit{modus ponens}. Via cela, on peut décider si un ensemble F de clauses est satisfaisables ou non. Forme la plus simple:$p \vee q \qquad \neg p \vee r \rightarrow q \vee r$.\\
Si on réalise une table de vérité, on peut voir que \textit{tout modèle des prémices est aussi un modèle de la conclusion}.

\subsubsection{Règles}
Si on a 2 clauses prémices $C_1$ et $C_2$, la première contenant $L_1=V$ et la seconde $L_2= \neg V$. On a une clause conclusion contenant tous les littéraux de $C_1$ et de $C_2$ sauf les littéraux $L_1$ et $L_2$
Exemples:
\begin{align*}
A &\vee B & A \vee &B \vee \neg C & A &\vee B & &A\\
\neg &A & \neg D \vee & \neg B \vee F & \neg A & \vee C & \neg & A \\
 \cline{1-8}
&B & A \vee \neg C & \vee \neg D \vee F & B &\vee C & &false 
\end{align*}

\subsubsection{Exécution}
À partir d'une formule CNF sous la forme de clause. on va à chaque étape:
\begin{enumerate}
\item Appliquer la règle de résolution sur deux clauses pour lesquelles la règle est applicable et dont la conclusion n'est pas une clause existante
\item Ajouter la clause conclusion à la formule CNF
\end{enumerate}
Si à une certaine étape, on ajouter la clause \textit{false} alors la formule \textcolor{red}{n'est pas satisfaisable}.\\
Si la règle de résolution ne peut plus s'appliquer alors la formule n'est pas satisfaisable.

\subsubsection{Exactitude}
On sait qu'à chaque étape, on a une formule \textit{CNF} qui est équivalente à la formule précédente.\\
On a un nombre de clauses distinctes, la formule est fini et donc son exécution se termine toujours.\\
Si une clause est \textit{false} alors la formule n'est pas satisfaisables.\\
Si fin sans clause \textit{false} alors la formule est non satisfaisable.

\subsubsection{Résultat}
La résolution nous indique si une formule \textit{CNF} appartient ou n'appartient pas à SAT. Si elle appartient à SAT, la résolution \textcolor{red}{ne donne pas} de modèle comme résultat.\\
On l'utilise pour prouver que $p \models q$ On transforme $(p \wedge \neg q)$ en \textit{CNF}:
\begin{itemize}
\item \textit{false}: alors $(p \wedge \neg q) \notin SAT$ donc $p \models q$
\item \textit{se termine}: alors $(p \wedge \neg q) \in SAT$ donc $p \nvDash q$
\end{itemize}
Exemple: $p = \{A, \neg B, \neg A \vee \neg C \vee D, \neg E \vee C, B \vee C \}$ mais $p \models D$? On applique la résolution à $p \cup \{\neg D\}$:
\begin{align*}
\neg A &\vee \neg C \vee D & \neg A & \vee \neg C & \neg &C & \neg & B\\
\neg & D & &A & B &\vee C & & B\\
 \cline{1-8}
\neg A & \vee \neg C & \neg & C & &B & &false 
\end{align*}
Donc $p \models D$


\chapter{Complexité algorithmique}
\section{Notions}
On peut demander qu'un programme est juste ou encore qu'il soit \textbf{efficace}. C'est la calculabilité et complexité respectivement. On regarde de manière pratique.

\subsection{Mesure}
On a deux types de complexité
\begin{enumerate}
\item Complexité spatiale, l'espace mémoire.
\item Complexité temporelle, le temps d'exécution.
\end{enumerate}
La complexité spatiale est \textit{toujours} inférieur à la complexité temporelle.

\subsubsection{Définition}
La complexité d'un problème est la complexité de l'\textcolor{red}{algorithme le plus efficace} résolvant ce problème.

\subsection{Comment mesurer ?}
La complexité dépend de la taille des données, de la représentation des données et du modèle de calcul utilisé \par
On a 3 grandes mesures:
\begin{enumerate}
\item Meilleur cas
\item Cas moyen
\item Pire cas
\end{enumerate}

\subsection{Calcul de complexité}
Pour la \textit{complexité d'un algorithme}, on peut soit utiliser des \textit{benchmarks} soit des analyses d'algorithmes.\par
Pour la \textit{complexité d'un problème} on utilise la complexité d'un algorithme le résolvant ou l'\textit{induction}.

\subsubsection{Benchmark}
On mesure le \textit{temps d'exécution} d'un certains programmes avec des certaines données sur une même machine. Ainsi, on peut comparer les machines et programmes entre eux

\subsubsection{Analyse mathématique}
On compare la complexité du programme à une fonction mathématique. On trouve une fonction $T(n)$ exprimant la complexité. $T(n)$ correspond au temps d'exécution du programme et est obtenu en analysant le texte du programme.

\subsubsection{Réduction}
On peut résoudre des problèmes en ayant un algorithme qui en résout un autre.

\section{Notation Grand O}
Tout temps d'exécution peut être résumé à une fonction polynomial. On regarde le meilleur et pire cas ainsi que le cas moyen.\par
On se contente souvent que de la complexité dans le pire des cas. Cela nous donne une borne supérieure.
\subsection{grand O}
Cela nous permet une caractérisation concise de classes de complexité. Cette notation est indépendante des évolutions technologiques.\\
On peut négliger les termes étant différent du terme à l'exposant le plus élevé. On ignore également le coefficient devant l'inconnu.

\subsection{Définition}
$O(g(n))$: le nombre d'étapes exécutés par le programme pour une donnée de taille $n$ n'est pas plus élevé que $cg(n)$ pour des tailles suffisamment grande.
\begin{equation}
T(n) \text{ est } O(g(n)) ssi \exists c,n_0 \forall n \geqslant n_0 : |T(n)| \leqslant c |g(n)|
\end{equation}

\subsection{Problèmes}
La notation grand O n'est pas très précise. $O(n^3)$ n'indique pas si on peut borner par $O(n^2)$ par exemple.

\subsubsection{Borne Inférieure}
La borne inférieure est $\Omega(g(n))$. Si $f(n) = O(g(n))$ alors $g(n) = \Omega(f(n))$

\subsubsection{Borne Exacte}
La borne exacte est $\Theta(g(n))$. Si $f(n) = O(g(n))$ et $f(n) = \Omega(g(n))$ alors $g(n) = \Theta(g(n))$

\section{Hiérarchie de complexités}
\begin{figure}[H]
\centering
\includegraphics[width=9cm]{img/BigO.jpeg}
\caption{Graphe de notation grand O}
\end{figure}
\noindent
Algorithmes quadratiques:
\begin{enumerate}
\item Tri par échange
\item Bubble sort
\item Addition de matrices $n\times n$
\end{enumerate}
Algorithmes cubiques:
\begin{enumerate}
\item Multiplication de matrices $n \times n$
\item Perspective d'une image 3D
\end{enumerate}
Algorithmes exponentiels
\begin{enumerate}
\item Voyageur de commerce
\item Coloration de graphes
\item Problèmes de planification
\item Problèmes d'ordonnancement 
\end{enumerate}

\section{Problème intrinsèquement complexe}
Ce sont les problèmes, qui étant calculables, ne peuvent être résolu à part pour des entrées très petites.\par
Si un problème n'a pas de complexité \textit{polynomiale}, alors il est \textcolor{red}{pratiquement infaisable}. Sinon il est \textcolor{blue}{pratiquement faisable}.\\

Un problème est intrinsèquement complexe \textit{ssi} il \textbf{n'existe pas} d'algorithme de \textcolor{blue}{complexité polynomiale}. Un problème intrinsèquement complexe est donc pratiquement infaisable.

\subsection{Influence du modèle de calcul}
Si un algorithme, exprimé dans un modèle de calcul particulier, est de complexité polynomiale, alors il sera également de complexité polynomiale dans un autre modèle de calcul (spatiale et temporelle).\par
Hypothèse de modèle de calcul réaliste (pas de non déterminisme).\par 
La classe de problème \textcolor{red}{intrinsèquement complexes} sont indépendants du modèle de calcul !\\
La seule influence qu'à un langage de programmation est qu'un problème est $O(n^2)$ en Java et $O(n^3)$ en Machine de Turing.

\subsection{Influence de la représentation des données}
Elle n'influence en aucun cas avec la propriété de \textcolor{red}{problèmes intrinsèquement complexes}. 


\chapter{Classes de complexité}
\section{Réduction et ensemble complet}
\subsection{Réduction}
Le but est de déduire un algorithme pour un problème $P$ à partir d'un algorithme résolvant $P'$.\par
Ici, on se limite au problème de décision pour un ensemble $E$ à partir d'un algorithme de décision pour $E'$.\\
Via cette définition, on va pouvoir:
\begin{enumerate}
\item Retourner des informations sur la calculabilité:
	\begin{enumerate}
	\item Permet de prouver la calculabilité
	\item Permet de prouver la non calculabilité
	\item Permet d'analyser le degré de non calculabilité
	\end{enumerate}
\item Retourner des informations sur la complexité:
	\begin{enumerate}
	\item Permet de déduire la complexité
	\item Permet d'analyser le degré de complexité
	\end{enumerate}
\end{enumerate}
Ainsi, on va utiliser 3 méthodes de réduction:
\begin{enumerate}
\item La réduction algorithmique: permet de déduire des propriétés sur la calculabilité
\item La réduction fonctionnelle:  permet de déduire des propriétés sur la complexité
\item La réduction polynomiale:  permet de déduire des propriétés sur la complexité
\end{enumerate}

\subsection{Algorithmique}
Un ensemble A est algorithmiquement réductible à un ensemble B si à partir d'un \textit{algorithme} permettant de reconnaitre B, on peut construire un algorithme permettant de reconnaitre A.\par
Un ensemble A est \textcolor{red}{algorithmiquement réductible} à un ensemble B ($A \leqslant_a B$) si en supposant B récursif, alors A est récursif.\par
$\leqslant_a$ est une relation réflexive et transitive. Cela induit des classes d'équivalence.

\subsection{Ensemble complet}
Un ensemble complet d'une classe d'ensembles est l'ensemble le "\textit{plus difficile}" à décider parmi tous les ensembles de la classe. Si on trouve un algorithme pour cet ensemble, alors on peut reconnaitre tous les autres ensembles de la classe. C'est le problème \textcolor{red}{point rouge}.

\subsubsection{Définition}
Ce \textcolor{red}{point rouge} d'une classe A est un problème E qui est \textbf{A-complet} par rapport à une relation de réduction:
\begin{enumerate}
\item $E \in A$
\item $\forall B \in A : B \leqslant E$ 
\end{enumerate}
Un problème E est \textbf{A-difficile} par rapport à une relation de réduction: $\forall B \in A : B \leqslant E$ il peut être en dehors de l'ensemble A.

\section{Propriétés}
\begin{itemize}
\item Si $A \leqslant_a B$ et $B$ récursif, alors A récursif
\item Si $A \leqslant_a B$ et $A$ non récursif, alors B non récursif
\item $A \leqslant_a \overline{A}$
\item $A \leqslant_a B \Leftrightarrow \overline{A} \leqslant_a \overline{B}$
\item Si A récursif alors pour tout B, $A \leqslant_a B$
\item Si $A \leqslant_a B$ et B récursivement énumérable, alors A pas nécessairement récursivement énumérable.
\end{itemize} 

\subsubsection{Exemples}
\begin{align*}
DIAG &\leqslant_a HALT & HALT &\leqslant_a DIAG
\end{align*}

\section{Fonctionnelle}
\subsection{Définition}
Un ensemble A est \textcolor{red}{fonctionnellement réductible} à un ensemble B ($A \leqslant_f B$) ssi il existe une fonction totale calculable $f$ tq:
\begin{equation}
a \in A \Leftrightarrow f(a) \in B
\end{equation}
Pour savoir si un élément appartient à A il suffit de calculer $f(a)$ et tester si $f(a) \in B$.

\subsection{Propriétés}
\begin{itemize}
\item Si $A \leqslant_f B$ et B récursif alors A récursif
\item Si $A \leqslant_f B$ et A non récursif alors B non récursif
\item Si $A \leqslant_f B$ récursivement énumérable, alors A récursivement énumérable
\item $A \leqslant_f B \Leftrightarrow \overline{A} \leqslant_f \overline{B}$
\item Si A récursif, alors pour tout $B,A \leqslant_f B$
\item Pas nécessairement $A \leqslant_f \overline{A}$
\item Si $A \leqslant_f B$ alors $A \leqslant_a B$
\item $A \leqslant_a B$ n'implique pas nécessairement $A \leqslant_f B$
\end{itemize}
Cela est plus restrictif car on doit voir s'il y a une appartenance à $B$ tel que $f(a) \leftarrow B$ et on doit l'exécuter.

\subsection{Exemples}
\begin{align*}
DIAG & \leqslant_f HALT & HALT &\leqslant_f DIAG
\end{align*}

\subsection{Différences entre algorithmique et fonctionnelle}
En $\leqslant_a$ on a un point de vue calculabilité et pour $\leqslant_f$ est un point de vue complexité. On doit donc appliquer un schéma d'algorithme suivant pour la \textit{complexité}. On a un input a, $a' := f(a)$ et si $a' \in B$ alors l'output est $a \in A$. On utilise en dernier lieu et une seule fois le test $f(a) \in B$. On ne fait rien après ce test.

\section{Modèle de calcul}
On théorie "\textit{classique}" la complexité se mesure via le modèle de machine de Turing. On regarde le nombre de \textit{transitions} nécessaires pour la complexité temporelle et le nombre de cases utilisées pour la complexité spatiale. La notion de \textit{transition} n'est pas très adapté pour les langages modernes.\par
On va utiliser le modèle des programmes Java. Donc déterministes et non déterministes. (on peut parfois faire des écarts pour utiliser le modèle le plus adapté)
\subsubsection{Thèse}
Tous les modèles de complexité ont entre eux des complexités spatiales et temporelles reliées de façon polynomiale.\par
Si un problème est \textit{pratiquement faisable} dans un modèle alors il l'est aussi dans un autre.

\section{Classes de complexité}
\subsection{Modèle déterministe}
On va déterminer des \textit{ensembles} de \textcolor{blue}{classe de problèmes} qu'on regroupe par leur $O$.\par
\textbf{DTIME(f)}: la famille des ensembles récursifs pouvant être décidés par un programme Java de complexité temporelle $O(f)$.\par 
\textbf{DSPACE(f)}: la famille des ensembles récursifs pouvant être décidés par un programme Java de complexité spatiale $O(f)$.\par
En complexité, on \textbf{n'a pas} de programme qui boucle.\par
\textcolor{red}{Attention}: $DTIME_{Java}(n^2) \neq DTIME_{Turing}(n^2)$ on sait juste qu'un complexité polynomiale en Java \textbf{sera} polynomiale en Turing mais pas égale !

\subsection{Modèle non-déterministe}
\textbf{NTIME(f)}: la famille des ensembles ND-récursifs pouvant être décidés par un programme Java non déterministe de complexité temporelle $O(f)$. On considère la complexité de la branche d'exécution \textbf{la plus longue}. Donc toutes les branches sont \textcolor{blue}{finies} et de complexité $O(f)$.\par
\textbf{NSPACE(f)}: la famille des ensembles ND-récursifs pouvant être décidés par un programme Java non déterministe de complexité spatiale $O(f)$.

\subsection{Classe}
\textbf{Classe P}: $P = \cup_{i \geqslant 0} DTIME(n^i)$ qui regroupe donc tous les programmes récursifs pouvant être décidé par une complexité temporelle \textcolor{red}{polynomiale}. Le fait que ce soit Java ou Turing ne change pas la classe.\par 
\textbf{Classe NP}: $NP = \cup_{i \geqslant 0} NTIME(n^i)$ qui est la famille des ensembles \textbf{ND-récursifs} pouvant être décidés par un programme Java \textit{non-déterministe} de complexité temporelle \textcolor{red}{polynomiale}.

\section{Relation entre les classes}
\subsection{Rapport déterminisme et non-déterminisme}
Si $A \in NTIME(f)$ alors $A \in DTIME(c^f)$. Il faut s'imaginer la façon dont on parcours l'arbre, de gauche à droite et de haut en bas. C'est une perte exponentielle d'efficacité.\\
Si $A \in NSPACE(f)$ alors $A \in DSPACE(c^f)$.

\subsection{Rapport temps et espace}
\begin{align*}
si A \in NTIME(f) &\text{ alors } A \in NSPACE(f) & si A \in DTIME(f) &\text{ alors } A \in DSPACE(f)\\
si A \in NSPACE(f) &\text{ alors } A \in NTIME(c^f) & si A \in DSPACE(f) &\text{ alors } A \in DTIME(c^f)
\end{align*}

\subsection{Hiérarchie de complexités}
Pour toute fonction totale calculable f, il existe un ensemble A récursif tel que $A \notin DTIME(f)$. On prouve cela par diagonalisation et même résultat pour NTIME, DSPACE et NSPACE.\par
Il existe toujours des problèmes plus complexes qu'une complexité donnée.

\chapter{NP-complétude}
On veut savoir si il existe un algorithme \textcolor{red}{non déterministe polynomiale}, existe-t-il alors un algorithme \textcolor{red}{déterministe polynomial} résolvant ce même problème?\par 
Si un ensemble A appartient à NP, A appartient-il alors à P ?
\begin{equation}
\textcolor{red}{P = NP}
\end{equation}

\section{NP-complétude}
On sait que $P \subseteq NP$. Mais comment démontrer que $NP \subseteq P$ ou pas. On peut prendre un élément \textbf{E} qui est "\textit{représentatif}" de NP et essayer de démontrer tel que:
\begin{itemize}
\item $E \in P$ alors on démontre que $P = NP$
\item Ou $E \notin P$ alors $P \neq NP$
\end{itemize}
Il faut choisir un élément qui soit NP-complet par rapport à une relation de réduction $\leq$
\begin{itemize}
\item $E \in NP$
\item $\forall B \in NP: B \leq E$
\end{itemize}

\subsection{Réduction algorithmique}
Si on réalise $\leq_a$. Si $A \leq_a B$ en supposant que A et B sont récursifs.\par 
Si on arrive à montrer que $E \in P$ on ne sait pas si $P = NP$. Car pour les autres éléments de NP, la réduction ne permet pas d'affirmer que ceux-ci sont dans P.

\subsection{Réduction fonctionnelle}
Si $A \leq_f B$ si il existe une fonction totale calculable $f$ telle que $a \in A \Leftrightarrow f(a) \in B$. Si on arrive à montrer que $E \in P$ on ne sait pas si $P = NP$. Car pour les autres éléments de NP, la réduction ne permet pas d'affirmer que ceux-ci sont dans $P$ . (le calcul de $f(a)$ peut prendre un temps non polynomial). On doit raffiner la réduction fonctionnelle.

\subsection{Réduction polynomiale}
Un ensemble $A$ est \textcolor{red}{polynomialement réductible} à un ensemble $B ( A \leq_p B)$. Si il existe une fonction totale calculable $f$ de \textcolor{blue}{complexité temporelle polynomiale} telle que:
\begin{equation}
a \in A \Leftrightarrow f(a) \in B
\end{equation}

\subsubsection{Propriétés}
\begin{enumerate}
\item $\leq_p$ est une relation réflexive et transitive
\item Si $A \leq_p B$ et $B \in P$ alors $A \in P$
\item Si $A \leq_p B$ et $B \in NP$ alors $A \in NP$
\end{enumerate}

\subsection{NP-complétude}
Un problème $E$ est NP-\textbf{complet} (par rapport $\leq_p$) si
\begin{enumerate}
\item $E \in NP$
\item $\forall B \in NP: B \leq_p E$ 
\end{enumerate}
Un problème $E$ est NP-\textbf{difficile} (par rapport $\leq_p$) si 
\begin{enumerate}
\item $\forall B \in NP: B \leq_p E$
\end{enumerate}

\subsection{Propriétés}
Soit $E$ est un ensemble NP-complet.
\begin{itemize}
\item $E \in P$ ssi $P = NP$
\item $E \notin P$ ssi $P \neq NP$
\item Si $E \leq_p B$ et $B \in NP$ alors est NP-complet.
\end{itemize}

\section{Théorème de Cook}
SAT: satisfaction des formules propositionnelles\par
Soit $W(A_1, ..., A_n)$ une formule propositionnelle dont les variables sont $A_1, ... A_n$. \par 
Si on a la formule $(\neg A \vee B ) \Rightarrow (A \wedge B)$ cette formule est satisfaisable avec A = B = true.
\subsection{Formalisation}
On utilise les connecteurs logiques, on a des variables $A_i$. On réalise des formules qui s'écrivent $W(A_1, ... , A_m)$ qui sont satisfaisables si il existe des valeurs logiques qui permettent que cette formule soit vrai.\par 
Si on a une longueur d'une formule $W$, on a $n$ occurrence de variables, alors la taille de $W = O(n log n)$.

\subsection{Théorème SAT NP-complet}
Donc $SAT \in NP$. Il existe un programme \textit{non déterministe} de complexité \textcolor{red}{polynomiale} capable de reconnaitre si une formule $W(A_1, ... , A_m)$ est satisfaisable.
\begin{enumerate}
\item On génère une séquence de $m$ valeurs logiques. $O(m)$ tel que $m \leqslant n$.
\item On substitue les occurrences des variables $A_i$ par leur valeur. $O( n log n)$
\item On évalue l'expression via la méthode de \textit{réduction}. Complexité \textit{polynomiale}.
\end{enumerate}

\subsubsection{$\forall B \in NP : B \leqslant_p SAT$}
Soit $B \in NP$. Il existe une \textbf{machine de Turing} non déterministe M qui reconnait en un temps polynomial $p(n)$ si un élément $x$ appartient à B:
\begin{itemize}
\item $p$ est un polynôme 
\item $n$ est la longueur de la donnée $x$
\end{itemize}
Donc la machine M dans toutes les branches d'exécutions possibles, s'arrêtent avant $p(n)$ mouvements.\\
La donnée $x$ est transformée en une formule \textit{propositionnelle} $W_x$:
\begin{itemize}
\item La taille de $W_x$ : $O(p(n))$ symboles
\item Transformation polynomiale: la construction de $W_x$ peut se faire en un temps \textit{polynomial} par rapport à $n$.
\item $x \in B \Leftrightarrow W_x \in SAT$
\end{itemize}

On va construite la formule $W_x$. À partir d'une donnée x et d'une machine de Turing non déterministe $M$, d'une formule $W_x$ dont les variables caractérisent le fonctionnement de la machine M sur la donnée x.

\section{Problèmes NP-complets}
Comment \textbf{prouver} qu'un problème est NP-complet. On peut soit
\begin{enumerate}
\item Réaliser une preuve comme à celle pour SAT (assez complexe) (il faut montrer que tous les problèmes peuvent s'y réduire)
\item Utiliser la propriété: $si E \leqslant_p B$ avec $E$ NP-complet et $B \in NP$ alors $B$ est \textbf{NP-complet}. (méthode la plus utilisée)
\end{enumerate}
Tous les problèmes considérés dans cette classe sont des problèmes de \textit{décision}.\par 
En pratique, on est intéressé par des \textit{algorithmes} qui construisent des solutions.\par 

\subsubsection{Problème du circuit Hamiltonien HC} 
$HC =$ ensemble des \textit{graphes} possédant un circuit hamiltonien (parcourant une seule fois tous les sommets).\par 
Le problème d'un circuit eulérien est lui dans P.

\subsubsection{Problème du voyageur de commerce TS}
Si nous avons $n$ noeuds et qu'on les relies via des arcs pondérés, Existe-t-il un circuit reliant les $n$ noeuds (villes) qui soit de longueur inférieur ou égal à un entier.\par 
$HC \leqslant_p TS$.

\subsubsection{Chemin le plus long entre deux sommets}
Si on a un graphe avec dans les noeuds $a$ et $b$. On veut savoir s'il existe un chemin reliant $a$ et $b$ qui est supérieur ou égal à un entier. (\textit{l'inverse aurait été P})

\subsubsection{3SAT}
Problème de la satisfaisabilité de formules de la forme $C_1 \wedge C_2 \wedge ... \wedge C_n$ avec:
\begin{align*}
C_i &= L_{i1} \wedge L_{i2} \wedge L_{i3} &  L_{i1} &= A_k \text{ ou }  L_{i1} = \neg A_k & A_k &= \text{ variable propositionnelle}
\end{align*}
Forme normale conjonctive avec $3$ variables par clause.

\subsubsection{Couverture de sommets VC}
Si on a un graphe et un entier positif $B$. Existe-t-il un sous-ensemble de sommets de taille $\leqslant B$ qui couvre tous les arcs du graphe.\par 
Le problème de la couverture des arcs est dans P.

\subsubsection{Problèmes de la clique}
Si on a un graphe et un entier positif $B$. Existe-t-il un sous-ensemble des sommets de taille $\geqslant B$ qui soit une clique (chaque paire de noeuds de ce sous-ensemble est reliée par un arc)

\subsubsection{Autres}
\begin{enumerate}
\item Nombre chromatique d'un graphe
\item Problème de partition
\end{enumerate}


\section{P = NP}
On a énormément chercher à prouver qu'il existe des algorithmes polynomiaux pour les problèmes NP-complets. Donc on pense que la solution est $P \neq NP$.

\subsection{En pratique}
Si un problème est \textit{NP-complet}. On sait que le problème n'a pas de solution algorithmique polynomiale. Mais il s'agit de la complexité dans le \textit{pire des cas}. On pourrait avoir une solution polynomiale pour certaines données.

\subsubsection{Résoudre}
\begin{itemize}
\item Changer le problème en un problème plus simple. Particulariser le problème
pour certaines instances
\item  Utiliser un algorithme exponentiel si la plupart des instances à résoudre sont
de complexité polynomiale
\item  Utiliser la technique d'exploration, mais en se limitant à un nombre polynomial
de cas (heuristique). Algorithme incomplet.
\item  Si problème d'optimisation, calculer une solution approximative.
\end{itemize}

\subsubsection{Transition de phase}
Beaucoup de problèmes NP-complets sont caractérisés par un \textit{paramètre} de contrôle. Cela induit 3 zones
\begin{enumerate}
\item Instances où presque tout est solution (quasi toujours \textit{oui})
\item Transition entre les deux régions
\item Instances où presque tout est solution \textit{non}.
\end{enumerate}
Le \textbf{pic de difficulté} se trouve dans la \textit{transition} et est \textbf{indépendant} de l'algorithme qui est choisi.

\subsection{Autres classes de complexité}

\subsubsection{Classe EXPTIME}
Famille des ensembles \textit{récursifs} pouvant être décidées par un programme de complexité \textcolor{red}{temporelle} $O(2^p)$ où $p$ est un polynôme.

\subsubsection{Classe LOGSPACE}
Famille des ensembles \textit{récursifs} pouvant être décidées par un programme de complexité \textcolor{blue}{spatiale} $O(log)$.

\subsubsection{Classe PSPACE}
Famille des ensembles \textit{récursifs} pouvant être décidées par un programme de complexité \textcolor{blue}{spatialle} $O(p)$ où $p$ est un polynôme.

\subsubsection{Classe NPSPACE}
Famille des ensembles \textit{ND-récursifs} pouvant être décidées par un programme de complexité \textcolor{red}{spatialle} $O(p)$ où $p$ est un polynôme.\par 
Mais: $PSPACE = NPSPACE$.
\begin{figure}[H]
\centering
\includegraphics[width=8cm]{img/classe.png}
\caption{relation entre classe}
\end{figure}

On a une classe intéressante qui est $NPI = NP \setminus NPC \setminus P$ qui est une sorte de \textit{no man's land}.

\chapter{Analyse et perspectives}
\section{Thèse de Church Turing}
Rappel: toute fonction calculable par une machine de Turing est donc calculable (logique). Toute fonction effectivement \textit{calculable} est calculable par une machine de Turing.\par 
La deuxième partie est considérée vraie par de nombreuses évidences.

\subsection{Évidences heuristiques}
La définition des machines de Turing s'approche de la notion intuitive de procédé effectif. On sait que toutes fonctions particulières s'avérant effectivement calculables ont été montrées être calculables par une machine de Turing.\par 
Il y a énormément de démonstration pour tout plein de classe de problème. On a toujours échoué à prouver qu'une fonction \textit{intuitivement calculable} ne soit pas calculable sur une machine de Turing.

\subsection{Équivalences des formalismes}
Les différentes définitions des mêmes formalismes de calculabilité ont conduit à la définition de la \textbf{même classe} de fonction calculables.

\subsection{Mécanisme de Calcul}
On a montré que tous les mécanismes de toutes les machines constructibles par la mécanique \textbf{newtonienne} ne peuvent calculer que des fonctions programmables.

\section{Formalismes de Calculabilité}
Qu'est-ce qu'un \textbf{bon} formalisme ?
Il doit être:
\begin{enumerate}
	\item \textbf{SD: Soundness des défintions:} \textcolor{red}{Toute fonction D-calculable est calculable}. Si il existe une description $d \in D$ calculant une fonction $f$ alors cette fonction est calculable. (\textit{première partie de C-T})
	\item \textbf{CD: Complétude des définitions:}  \textcolor{red}{Toute fonction calculable est D-calculable}. Si une fonction $f$ est calculable, alors il existe une description $d \in D$ calculant cette fonction $f$. (\textit{deuxième partie de C-T})
	\item \textbf{SA: Soundness algorithmique:} \textcolor{red}{L'interpréteur de D est calculable}. Toute description $d \in D$ peut être effectivement exécutée sur des données. Le formalisme $D$ est algorithmique. Cette caractéristique assure que $D$ décrit bien des procédés effectifs.
	\item \textbf{CA: Complétude algorithmique:} Si P est SA, alors il existe un compilateur (\textit{calculable}) tel que étant donné $p \in P$, ce compilateur appliqué à $P$ produit une description $d \in D$ avec $p$ équivalent à $d$. Cela assure une équivalence des formalismes.
	\item \textbf{U: description universelle:} \textcolor{red}{L'interpréteur de D est D-calculable}. Le formalisme doit permettre de décrire son propre interpréteur. (\textit{Hoare-Allison})
	\item \textbf{S: propriété S-m-n affaiblie:} $\forall d \in D \quad \exists S : d(x,y) = [S(x)](y)$. Il existe un \textcolor{blue}{transformateur de programme} (\textit{total calculable}), qui recevant comme données un programme $d$ à $2$ arguments et une valeur $x$, fournit comme résultat une programme à \textcolor{red}{$1$} argument tel que les deux fonctions calculent la même chose.
\end{enumerate}

\subsection{Propriétés}
\begin{align*}
SA & \Rightarrow SD & &\text{Il existe un interpréteur de D qui est calculable SA.\linebreak Donc calculable via SD}\\
CA & \Rightarrow CD & &\\
SD \text{ et } U &\Rightarrow SA & &\text{propriétés U rajoutées}\\
CD \text{ et } S &\Rightarrow CA & & \\
SA \text{ et } CD &\Rightarrow U & & \\
CA \text{ et } SD &\Rightarrow S & & \\
S \text{ et } U &\Rightarrow S-m-n & & \\
SA \text{ et } CA &\Rightarrow SD \text{ et } CD \text{ et } U \text{ et } S & & \\ 
SA \text{ et } CD \text{ et } S &\Rightarrow CA \text{ et } SD \text{ et } U & &    
\end{align*}

On peut avoir une partie des formalismes mais cela rend notre formalisme \textcolor{red}{mauvais}. Bloop était SD, SA et S mais pas le reste.

\section{Techniques de raisonnement}
Comment démontrer la \textbf{non calculabilité} d'une fonction. Voici un schéma de raisonnement:
\begin{enumerate}
	\item Essayer de trouver un algorithme qui résout le problème 
	\item Se demander si suspicion possible de non \textit{calculabilité} du problème. (aucun algorithme)
	\item Essayer de prouver la non calculabilité
	\item Si c'est le cas, essayer de définir une version du problème approchée qui est calculable.
\end{enumerate}

\subsection{Techniques de preuve}
On va utiliser Rice: s'intéresser à la fonction du programme conduit souvent à la non calculabilité.\par 
Démonstration directe par la non calculabilité via une diagonalisation ou une preuve par l'absurde.\par 
Méthode de réduction:
\begin{enumerate}
	\item Réduire la solution d'un problème $A$ à celle d'un autre problème $A'$ ($A$ est un cas particulier de $A'$)
	\item À partir d'un algorithme pour $A'$ construire un algorithme pour $A$.
	\item Conclusion, si $A'$ est calculable alors $A$ l'est aussi. Si $A$ est non calculable alors $A'$ est non calculable.
\end{enumerate}

\subsection{Problème intrinsèquement complexe}
Une complexité exponentielle est juste une borne supérieure et peut avoir des algorithmes polynomiaux.\par 
On peut essayer de faire une réduction d'un problème NP à notre problème.\par 
Existe-t-il un algorithme ND polynomial. Si oui, le problème est dans NP.

\subsubsection{Résoudre}
On utilise un algorithme exponentiel si la plupart des instances à résoudre sont de complexité polynomiale.\par 
Changer le problème en un problème plus simple (polynomial) qui est proche du problème initial.\par 
Utiliser une technique d'exploration, mais en se limitant à un nombre polynomial de cas (\textit{heuristique}). L'algorithme est incomplet. Il peut donner une réponse erronée ou approximative. Mais c'est parfois mieux que pas de réponse du tout.\par 
Si problème d'optimisation, calculer une solution approximative.

\section{Aspects non couverts par la calculabilité}
Une grande parties des programmes \textbf{ne peuvent pas} être résumées au calcul de fonction: IoT, OS, app, ...\par
La définition de la \textcolor{red}{calculabilité} cherche si il existe un programme qui calcule cette fonction. On veut voir les \textbf{conséquences} de la non calculabilité.

\subsection{Ressources}
Une fonction calculable en \textit{théorie} peut être non calculable en \textit{pratique} (trop de ressources, ...). La calculabilité ne détermine pas ça.

\section{Au delà de la calculabilité}
\subsection{Calculabilité et intelligence humaine}
Si un être humain particulier est capable de calculer une fonction particulière (\textit{en un temps fini}). Alors on dit que la fonction est \textit{H-calculable}. Cela est-il équivalent à la calculabilité d'un ordinateur ?

\subsection{Thèse: version procédés publics}
Si une fonction est H-calculable et que l'être humain calculant cette fonction
est capable de décrire (à l'aide du langage) à un autre être humain sa
méthode de calcul de telle sorte que cet autre personne soit capable de
calculer cette fonction,
alors la fonction est T-calculable
Cette version n'exclut pas l'existence de fonctions H-calculables, mais non
calculables

\subsection{Thèse CT: version réductionniste}
Si une fonction est H-calculable, alors elle est T-calculable. Le comportement des éléments constitutifs d'un être vivant peut être simulé
par une machine de Turing. Tous les processus cérébraux dérivent d’un substrat calculable

\subsection{Thèse CT:  version anti-réductionniste}
Certains types d'opérations effectuées par le cerveau, mais pas la majorité d'entre elles, et certainement pas celles qui sont intéressantes, peuvent être exécutées de façon approximative par les ordinateurs. Certains aspects seront cependant toujours hors de portée des ordinateurs.
\begin{equation}
H-calculable \neq T-calulable
\end{equation}


\subsection{Calculabilité et intelligence artificielle}
Il y a 2 types:
\begin{itemize}
	\item \textbf{IA forte:} simulation du cerveau humain à l'aide d'un ordinateur en copiant le fonctionnement. On veut des résultats similaires.
	\item \textbf{IA faible:} programmation de méthodes et techniques de raisonnement en exploitant les caractéristiques propres des ordinateurs.
\end{itemize}
IA forte $\approx$ version réductionniste de CT.

\subsubsection{Puissance cerveau humain}
Un cerveau humain fait $10^{18}$ instructions par seconde. Le plus puissant fait $442$ PFlops ($10^{15}$). Qui correspond à environ $10^{18}$.

\subsubsection{Machine et la pensée}
On peut réaliser le \textcolor{red}{test de Turing}. On pose des questions au pc et à l'être humain par écrit. Si la personne qui pose les questions ne peut déterminer la différence entre les deux alors on atteint la singularité et l'ordinateur réussie le \textbf{test de Turing} (perdre 1 fois sur 2) et donc les machines peuvent penser.

\section{Au delà des modèles de calculs}
\begin{wrapfigure}{r}{.5\textwidth}
\centering
\includegraphics[width=6cm]{img/quantum.png}
\caption{Espace \textit{supposée} des relations BQP et NP}
\end{wrapfigure}
La frontière entre calculabilité et non calculabilité est indépendante du progrès technologiques.\par 
Mais si on a des nouvelles technologies, peut-on dépasser ces limitations ?

\subsection{Ordinateur quantique}

Il ne donne pas un seul résultat mais une \textbf{superposition de résultat} avec un probabilité.\par 
Une nouvelle classe est \textbf{BQP} ou Bounded-error Quantum Computing. Si il existe un algorithme \textit{quantique} polynomial qui donne la bonne réponse au moins 2 fois sur 3.\par 
L'espace BQP ne comprend pas les problèmes NP-Complet mais dépasse dans les problèmes PSPACE et NP.



\chapter{Questions Test d'entrée}

\section{TP1}
\begin{enumerate}
\item Effectivement, il existe une bijection entre les N et les nombres impairs positifs $\rightarrow$ en somme il existe une fonction qui transforme les N en impair positif
\item J'imagine qu'il y a une bijection mais je ne vois pas quel formule passant de N aux impairs existent car c'est le propre des nombres impairs 
\item Même raisonnement que la question 1
\item La fameuse formule qui lie N et Q car Q est juste une paire de N
\item Effectivement, sachant la diagonalisation de Cantor il est simple de le prouver
\item Pour N dans N il en existe une infinité et l'ensemble d'arrivé ne change pas grand-chose car on s'intéresse au nombre de fonction.
\item Effectivement, on a un nombre fini de langage donc de mot. Cela est dû grâce à l'alphabet fini et la longueur fixe. Donc on sait énumérer
\item Question typique vu au cours. En effet comme on a une infinité et il n'existe aucune bijection depuis les naturels etc.
\item Même cardinalité = bijection, il ne peut y avoir de bijection entre un ensemble non énumérable et énumérable
\item Une infinité de nombre mais effectivement même cardinalité car tous peuvent être ramené aux naturels.


\end{enumerate}

\section{TP2}
\begin{enumerate}
\item Effectivement, on ne doit pas être en capacité de coder l'algorithme pour que la fonction soit calculable.
\item Nombre premier est récursif car on a le crible d'eratosthène.
\item Si un ensemble $\textbf{X}$ est récursif (donc donne 1 ou 0) alors $\bar{X}$ l'est également car il inverse les 1 et 0.
\item Si $\textbf{X}$ est récursivement énumérable (donne 1 ou quelque chose d'autre mais pas 1) et que son opposé $\bar{X}$ est récursivement énumérable. Alors bien évidemment $\textbf{X}$ est récursif.
\item Oui, trivial.
\item Non, juste au simple fait que si $\textbf{X}$ est récursivement énumérable alors $\bar{X}$ ne peut être récursivement énumérable.
\item Vrai car on a une fonction calculable car ce sont des combinaisons linéaires de calculables.
\item Voir sous-section \ref{caract}.
\item Oui car être énumérable c'est dire qu'on peut compter tous les résultats même si ça prend un temps infini.
\item Voir sous-section \ref{caract}.
\end{enumerate}

\section{TP3}
\begin{enumerate}
\item En effet, si on a que des fonctions totales, on sait qu'on aura toujours une réponses pour n'importe quelle input.
\item Oui, le théorème de \textit{Hoare-Allison} ne dit pas l'inverse et pour le sous langage:
\begin{lstlisting}
P = return 1;
\end{lstlisting}
\item Mais si on peut avoir la fonction halt en L, on ne peut avoir sa fonction \textit{interpret}
\item Mais, on peut calculer cette fonction \textit{interpret} avec un langage de programmation qui n'est pas \textcolor{red}{restrictif}.
\item Effectivement on ne peut pas calculer toutes les fonctions totales avec L.
\item Il existe un langage qui peut calculer sa fonction halt et son interpréteur (le langage vide trivial)
\item Effectivement, ne pas être récursif n'empêche pas d'être récursivement énumérable.
\item Faux exemple: $\overline{\textbf{K}}$. (voir \ref{coreq})
\item Non, on peut imaginer 2 fonctions non récursives qui se "\textit{complètent}" et comblent les lacunes de chacune. Exemple: $K \text{ et } \overline{K}$
\item Non, on peut imaginer une intersection qui ne comportent que des entrées avec une réponse.
\end{enumerate}

\section{TP4}
\begin{enumerate}
\item Faux, l'ensemble des programmes qui ont pour fonction $2n$ est non récursif car notre ensemble à toutes les fonctions qui ont ce résultat.
\item Faux, car on possède toutes les fonctions qui renvoient $0$ pour n'importe quelle entrée.
\item Vrai, car certains programmes peuvent hors de notre ensemble ont la même fonction. C'est le \textit{1000 instructions} qui posent soucis. Car des programmes qui en ont + peuvent retourner le même résultat.
\item Faux, en effet un programme qui prend 3 entrées (donc hors de notre ensemble) a le même résultat qu'un faisant partie de notre ensemble. Et ceci est valable pour \textbf{tous} programmes dans notre ensemble.
\item Cela dépend de la fonction f, en effet, même sorte de raisonnement que pour le 4. donc cela dépend. On peut aussi avoir des fonctions non calculables.
\item Il faudrait tester toutes les entrées pour en être sûr donc $\mathbb{N}$.
\item Oui, voir l'idée avec halt, ...
\item C'est l'ensemble formé par Halt donc pas récursif.
\item Mais c'est bien récursivement énumérable comme Halt.
\item Non, il faut faire une réduction à halt.
\end{enumerate}

\section{TP5}
\textcolor{red}{à ajouter}

\section{TP6}
\textcolor{red}{pas présent}

\section{TP7}
Les 5 premières questions sont des applications \textit{calculatoires} de machine de Turing. Simplifiez vous la vie en utilisant ce \href{https://turingmachine.io}{site} et utilisez ce code.
\begin{lstlisting}[showstringspaces=false]
input: 'bbba'
blank: ' '
start state: start
table:
  start:
    'a'   : {write: 'x', R: seekB}
    'b'   : {write: 'x', R: seekA}
    'x'   : {write: ' ', R: start}
    ' '   : {write: 1, L: done}
  seekA:
    'a'       : {write: 'x', L: restart}
    ['b', 'x']: {R: seekA}
    ' '       : {L: falseFun}
  seekB:
    'b'       : {write: 'x', L: restart}
    ['a', 'x']: {R: seekB}
    ' '       : {L: falseFun}
  restart:
    ['a', 'b', 'x'] : {L: restart}
    ' '             : {R: start}
  falseFun:
    ['a', 'b', 'x'] : {write: ' ', L: falseFun}
    ' '   	    : {write: 0, L: done}
  done:
\end{lstlisting}
\begin{enumerate}
\item \textcolor{green}{Vrai} c'est le principe même et le but d'une machine de Turing, montrer qu'un langage de programmation est récursif.
\item \textcolor{red}{Faux}, on peut penser à un tableau simple de Turing qui bouge le ruban une fois à droite puis à gauche.
\item \textcolor{red}{Faux}, non-déterministes donc plusieurs applications et "futures" possibles. Cependant, cela n'avantage en aucun sa puissance, juste sa rapidité et facilité d'implémentation.
\item \textcolor{red}{Faux}, on n'a pas besoin d'un oracle qui \textit{voit une case devant} pour savoir si une entrée est paire. L'ensemble des nombres pairs est \textbf{récursifs} donc oracle inutile.
\item \textcolor{green}{Vrai}, car on serait incapable sans oracle de savoir si un programme ne boucle pas donc on veut avoir \textbf{HALT}.
\end{enumerate}

\section{TP8}
\textcolor{red}{pas fait oopss}

\section{TP9}
\begin{enumerate}
\item On a une complexité de $O(n^2)$ car on a une double boucle for. Pas la borne exacte mais la plus proche.
\item On a une complexité de $O(ln(n))$ car on divise le travail en deux à chaque itération.
\item On a une complexité de $O(n)$ car on divise et double le travail donc on reste à $n$.
\item Petit indice dans son nom "\textit{explosion}", on a $O(2^n)$ car à chaque entrée on dédouble le tout et on est récursif.
\item \textcolor{green}{Vrai} puisque les bornes donnent une limite supérieure.
\item \textcolor{red}{Faux} car on peut avoir un $g(n)$ d'un degré inférieur que $f(n)$ ce qui par l'\textit{Hospital} nous donnerait une limite \textit{infinie}.
\item \textcolor{red}{Faux} c'est en $O(n^3)$
\item \textcolor{red}{Faux}, être intrinsèquement complexe est une complexité \textit{non-polynomiale}.
\item \textcolor{red}{Faux}. En effet, pour de faibles tailles de données on peut facilement trouver le résultat.
\item \textcolor{red}{Faux}. C'est l'utilité de cette notation. Un pc 100 fois plus puissant nous permettrait que d'augmenter la taille de l'entrée de $2$ ou $3$.
\end{enumerate}

\section{TP10}
\begin{enumerate}
\item \textcolor{red}{Faux}, pas forcément !
\item \textcolor{green}{Vrai}, une réduction $\leqslant_a$ peut permettre de prouver qu'un ensemble est récursif
\item \textcolor{red}{Faux}, mais ne peut pas prouver que ce n'est pas récursif
\item \textcolor{green}{Vrai}, on peut prouver qu'un ensemble est récursif via $\leqslant_f$
\item \textcolor{green}{Vrai}
\item \textcolor{red}{Faux}, car on ne sait pas si $C$ n'est pas le problème le plus compliqué de l'ensemble.
\item \textcolor{red}{Faux}, non on ne sait pas obtenir une borne exacte
\item \textcolor{green}{Vrai}
\item \textcolor{red}{Faux}, car la complexité est plus élevé sur une machine de Turing
\item \textcolor{red}{Faux}, Non il y a d'autres problèmes qui ne peuvent pas être résolu par des algorithmes non polynomiaux qui ne sont pas dans les \textbf{NP}.
\end{enumerate}


\chapter{Question cours}
\section{S1}

\section{S2}
Une densité du nombre de rationnel
Un langage est un ensemble de chaine de caractère ! Attention de ne pas confondre langage le mot vulgaire et langage en informatique.\\
Fonction totale s'intéresse au domaine.\\
Fonction surjective s'intéresse à l'image.\\
\begin{itemize}
\item Injective max une flèche.
\item Surjective min une flèche.
\item Étendre une fonction est rajouté une flèche.
\end{itemize}

\section{S3}
Attention à la notation entre$ \rightarrow P_{12} \neq P_{47}$ car $P$ sont des chaines de caractères bien déterminés et donc différentes
$\varphi_{12}=\varphi_{47}$ effectivement car phi est créé depuis des P différents mais peuvent créer des fonctions donnant le même résultat\\

$Halt(n,37)$ n'est pas calculable car si ce serait, halt serait calculable\\
Print(1) car tous les Entiers appartiennent à $\mathbb{N}$\\

Recursif: calculable
Récursivement énumérable: calculable et ne dit pas s'il ne l'est pas.

\section{S4}
Différence entre Q et JAVA, toutes les fonctions se terminent et rendent une valeur. 
Java lui peut rendre une fonction bottom !
Donc notre démonstration ne fonctionne plus car $interpret(k,k)= \perp$ et donc $diag_{mod}= \perp+1= \perp$\\

Est-ce le fait qu'un interpréteur ne puisse être écrit en Q problématique ?
Un interpréteur prend en entrée un code et met des mots-clés. L'interpréteur va créer un arbre d'exécution.\\
SQL est un langage qui ne boucle jamais. $\rightarrow$ Donc SQL ne peut être utiliser pour faire des programmes complexes.\\

Impossible de détecter les cas sans réponses. (fonction HALT en exemple)

\section{S6}
\begin{enumerate}
\item Pourquoi la propriété S est-elle une conséquence du théorème S-m-n ? Avec le théorème S-1-1 Il existe une fonction totale calculable $S_1^1:N^2\rightarrow N$
\item Lesquelles de ces affirmations sont vraies
\begin{enumerate}
	\item Si f est une transformateur de programmes (f fonction totale calculable), alors il existe deux programmes P1 et P2 tels que $f(P1) = P2$ ainsi que P1 et P2 calculent la même fonction  Le théorème de u point fixe
	\item Si f est une transformateur de programmes (f fonction totale calculable), alors il existe deux programmes P1 et P2 tels que f(P1) = P2 ainsi que P1 et P2 calculent la même fonction totale $\rightarrow$ le totale nous force à avoir quelque chose qui se termine toujours
\end{enumerate}
\item À quoi sert le théorème du point fixe:
\begin{enumerate}
\item Faire un programme qui sans paramètre donne son propre code en sortie standard
\end{enumerate}
\item Post $\rightarrow$ impossible même avec Bruteforce. Diophantienne $\rightarrow$ l'utilité est minime.
\item Nombre réels non-calculables est-elle une conséquence immédiate du fait que R est non énumérable.
Donne un output fini aussi précis que je le voudrais. R n'est pas énumérable et j'ai un nombre énumérable de programme donc je ne peux pas représenter tous les R.
\end{enumerate}

\section{S7}
\begin{itemize}
\item \textcolor{blue}{Sémantique}: signification du programme et sa fonction calculé
\item \textcolor{blue}{Syntaxique}: comment écrire correctement le programme et qu'il soit compréhensible par l'ordinateur
\end{itemize}

Si un ensemble A est ND-récursif, les différentes exécutions du programme ND-Java qui décide cet ensemble doivent-elles nécessairement se terminer pour chaque input possible.$\rightarrow$ ce sont des arbres de décisions (accepter les résultats si oui ou non etc)\\

Tant qu'une façon d'avancer dit oui même avec une boucle infini, on peut accepter.\\
Quel est le but d'un langage non déterministe car pas exécutable sur un pc? Car sinon on va saturer et on n'aura pas assez de cœur et on passera en séquentiel. (ex: parcours en largeur): C'est pour modéliser des problèmes\\

Avec BLOOP je peux calculer des choses mais pas toutes les fonctions totales et calculables (hoare allison)\\

Automate fini chose simple qui répète toujours la même chose en boucle sans dépendre du passé.\\

Par hoare allisson que les automates sont toujours finis et s'arrête\\

Si on a une façon acceptante, on peut toujours l'accepter et dire oui.\\

On ne peut pas programmer toutes les fonctions calculables en automate fini

\chapter{Vrai ou Faux cours} %améliorer la mise en page
Cette section regroupe toutes les réponses et raisonnements des questions \textbf{wooclap} posées au cours.

\section{S1}
Introduction donc pas de QCM.

\section{S2}
\textcolor{red}{Besoin de contributeurs}
Je n'ai pas noté :(( 
%ajoutez le questionnaire

\section{S3}
%ajouter les questions pas que les réponses
\textcolor{red}{TODO ajouter les questions pas que les réponses}

\begin{enumerate}
\item Tout language n'est pas récursif car c'est un ensemble de fonction dont Halt qui n'est pas récursif
\item Tout ensemble énumérables n'est pas récursif.
\item Un ensemble fini est récursif
\item Le complément d'un ensemble récursif est récursif
\item L'ensemble des rationnels est récursivement énumérable
\item Un sous-ensemble infini d'un ensemble récursivement énumérable n'est pas récursivement énumérable
\item Un sous-ensemble fini d'un ensemble récursivement énumérable n'est pas récursivement énumérable
\item L’union d’une infinité énumérable d’ensembles récursivement énumérable n'est pas récursivement énumérable: Exemple avec l'ensemble K
\item Le complément d’un ensemble récursivement énumérable n'est  pas récursivement énumérable: Exemple avec K et inverse de K
\item Une fonction dont la table est infinie est calculable
\item Un algorithme ne calcule qu'une et une seule fonction
\item Il existe des ensembles non récursivement calculable
\item Une fonction calculable est peut être calculée par une infinité de programmes
\item L'ensemble HALT n'est pas récursivement énumérable
\item Il existe des ensembles récursifs qui sont récursivement énumérables
\item Il existe des ensembles récursifs qui ne sont pas énumérables
\item Si le domaine d'une fonction est finie, alors cette fonction est calculable: on peut faire une liste de tous les cas possibles
\item Si le domaine de fonction est infini, alors cette fonction est calculable
\end{enumerate}

\section{S4}
\begin{enumerate}
\item Il existe un langage non trivial dans lequel la fonction halt est calculable. $\rightarrow$ on sait que tout ce fini en Q donc oui on sait calculer halt car c'est la fonction constante 1 (non trivial $\rightarrow$ pas les réponses facile type langage vide)
\item Il n'existe pas un langage de programmation (non trivial) dans lequel on peut programmer le fonction halt ainsi que l’interpréteur de ce langage
\item Si un langage de programmation (non trivial) permet de programmer son interpréteur, alors la fonction halt n'est pas calculable dans ce langage
\item Il existe de langage de programmation (non trivial) dans lequel toutes les fonctions calculées sont totales
\item Il n'existe pas un langage de programmation ne permettant de calculer que des fonctions totales, mais toutes les fonctions totales calculables $\rightarrow$ l'interpréteur ne peut pas être calculé en Q
\item il n'existe pas une fonction totale calculable qui n'est l'extension d'aucune fonction partielle calculable $\rightarrow$ effectivement car on a une fonction calculable totale elle est d'office l'extension d'une fonction partielle calculable.
Il existe une fonction partielle calculable telle qu’aucune fonction totale calculable n’est une extension de cette fonction partielle --> énoncé du théorème, pas de messages d'erreur.
\end{enumerate}

\section{S5}
\begin{enumerate}
\item L'ensemble des programmes Java calculant une fonction $f$ telle que $f(10) = 10$ n'est pas récursif (car ici on caractérise que fait le programme !)
\item L’ensemble des programmes Java calculant une fonction $f$ telle que $f(10)=10$ est un ensemble récursivement énumérable. (n'a aucun rapport avec Rice !!!)
\item Toute propriété relative aux programmes est calculable (théorème de rice parle des propriétés calculés par la fonction pas lié à la fonction
\item Si A est un sous-ensemble (strict et non vide)  récursif de programmes Java, alors toute fonction calculée par un programme de A n'est pas aussi calculée par un programme du complément de A (car il existe pas qu'il existe pour tout !!!)
\item Soit la fonction $revenu1_yde(n) =$ le revenu imposable de Yves Deville à l'année $n$.  Si n est inférieur à $1960$ ou supérieur à $2060$, le résultat de cette fonction est $\perp$. Par hypothèse, une personne décédée a un revenu de $0$.  Cette fonction est-elle calculable ? (Car n'est définie que pour $101$ inputs. Calculable car nb fini de point à calculer. Domaine finie == calculable au sens théorique du terme)
\item Soit la fonction $revenu2_yde(n) =$ le revenu imposable de Yves Deville à l'année $n$. Par hypothèse, une personne pas encore née ou décédée a un revenu de $0$. Cette fonction est-elle calculable ? ( car est constante sauf pour un certain input. Ici on n'est jamais bottom donc il existe toujours une fonction)
\item Un programme Java étant fini, l’exécution de ce programme sera aussi finie (car il peut boucler)
	Soient les programmes $P_32$ 
\item (n) dont le code est « print(1) » et $P_57(n)$ dont le code est « print(0) ».  Cochez les affirmations correctes (on peut pas varier de l'un à l'autre)
\item Une extension d’une fonction partielle calculable est toujours calculable (faux car il existe des fonctions qui ne peuvent être étendue ex: HALT)
\item L’ensemble des sous-ensembles des entiers est énumérable (car autant que les réelles, on a besoin d'une chaine infinie de caractère)
\item Il existe un ensemble infini de chaînes finies de caractères (A-Z) qui est non énumérable (on peut créer des chaines de caractères de chiffres et ce sera fini)
\item Il existe un ensemble infini de chaînes finies de caractères (A-Z) qui est non récursivement énumérable (ensemble non récursif $\rightarrow$ complément K $\rightarrow$ c'est une représentation
\item La fonction $halt(18,x)$ est calculable (cela dépend de la numérotation choisie des programmes Java)
\item L'ensemble des fonctions non calculables est énumérable (Faux car infinité)
\item Soit A est un ensemble (infini) récursivement énumérable.  Si $ B \subseteq A $, alors $B$ est aussi récursivement énumérable. (Faux car le sous-ensemble peut prendre que des choses bottoms)
\item Il existe des langages de programmation (non triviaux) dans lesquels toutes les fonctions calculées sont totales (Vrai, mini-Java ne calcule que des fonctions totales et calculables. Toutes les fonctions sont totales)
\item Si une fonction $f$ est calculable, alors toute fonction g dont f est une extension est calculable (Faux, $\rightarrow$ le théorème de l'extension parle pas de ça. Car g peut être bottom et donc ne pas être calculable (genre 1 si élément appartient au complément de $K$ ou $\perp \rightarrow$ fonction pas calculable et $f$ est une extension))
\item Soit le programme numéro n calculant la fonction factorielle ($f(x)=x!$ si $x$ non négatif et $f(x)=\perp$ si $x$ négatif,).  Cochez les affirmations correctes:
	\begin{enumerate}
	\item $\varphi_l(n)$ calcule bien quelque soit l'énumération choisie pour les programmes
	\item Pas énumération car n est positif
	\item Une infinité de programmes calculent la même fonction
	\item Par hasard
	\item Pas injectif car ne fait d'office correspondre au max $1$ une fois. (penser à $0!$ Et $1!$ Même réponse)
		\end{enumerate}

\end{enumerate}

\section{S6}
\begin{enumerate}
\item La propriété S-m-n affirme que tout numéro de programme calculable peut être transformé en un numéro équivalent, mais avec moins de paramètres $\rightarrow$ \textcolor{red}{Faux}, on transforme un programme en un autre programme. Les fonctions sont équivalentes.
\item Les propriétés S-m-n et S  sont équivalentes $\rightarrow$ \textcolor{red}{Faux}, S-m-n implique S mais pas dans l'autre sens.
\item Tous les langages de programmation (standards) satisfont la propriété S-m-n, on peut spécialiser un programme par ses arguments
\item Le théorème du point fixe est une conséquence du théorème de Rice $\rightarrow$ \textcolor{red}{Faux} c'est l'inverse
\item Si deux programmes P1 et P2 calculent la même fonction, alors il existe un transformateur f de programmes (f  fonction totale calculable) , tel que f(P1)=P2 $\rightarrow$ \textcolor{green}{Vrai}, ce n'est pas le théorème du point fixe. On a 2 programmes qui calculent la même fct, on une fct qui transforme P1 et P2 (return P2)
\item Si f est un transformateur de programmes (f  fonction totale calculable),  alors il existe deux programmes P1 et P2 tels que f(P1)=P2 ainsi que  P1 et P2 calculent la même fonction $\rightarrow$ \textcolor{green}{Vrai} énoncé du point fixe mais un peu moins math.
\item Si f est un transformateur de programmes (f  fonction totale calculable),  alors il existe deux programmes P1 et P2 tels que f(P1)=P2 ainsi que  P1 et P2 calculent la même fonction totale $\rightarrow$ \textcolor{red}{Faux}, attention au totale, on n'exige pas que les programmes s'exécutent toujours.
\item Le théorème du point fixe permet de démontrer que la fonction halt  est non calculable $\rightarrow$ \textcolor{green}{Vrai}, pt-fixe donne halt
\item La non calculabilité du problème de Post est une conséquence du théorème de Rice $\rightarrow$ \textcolor{red}{Faux}, c'est une autre famille de problème non calculables, c'est lié au problème des chaines de caractères
\item L’ensemble des nombres réels calculables est énumérable $\rightarrow$ \textcolor{green}{Vrai} car on l'approche via un programme et le nombre de programme est calculable
\item Il existe une infinité non énumérable de nombres réels non calculables $\rightarrow$  \textcolor{green}{Vrai} les réels calculables sont énumérables donc l'ensemble opposé doit être non énumérable sinon ça voudrait dire que les réels sont énumérables.
\end{enumerate}

\section{S7}
\begin{enumerate}
\item Toutes les fonctions calculables par les programmes du langage BLOOP sont totales $\rightarrow$ \textcolor{green}{Vrai} toujours terminé donc tot
\item Le langage BLOOP (Bounded Loop) ne permet de programmer que des fonctions totales.  Il existe donc des fonctions totales calculables qui ne peuvent être programmées dans ce langage. $\rightarrow$ \textcolor{green}{Vrai} hoare allison
\item Les langages non déterministes permettent d’écrire des algorithmes plus efficaces. $\rightarrow$ \textcolor{red}{Faux}, plus simple de les exécuter mais on ne peut pas exécuter tout en parallèle
\item Tout ensemble ND-récursivement énumérable  est récursif $\rightarrow$ \textcolor{red}{Faux}, ND et déterministe est la même chose. Cela n'apporte rien en calculabilité. ND facilite la description de problème. Donc est-ce un ensemble récursivement énumérable récursif ? Faux bien évidement
\item Il existe des ensembles récursifs ne pouvant être décidés par un automate fini $\rightarrow$ \textcolor{green}{Vrai}, HOARE ALLISON ! Tous les programmes se terminent 
\item Tout automate fini non déterministe peut être transformé en un automate fini déterministe équivalent $\rightarrow$ \textcolor{green}{Vrai}, un programme non déterministe Java peut être transformé en déterministe en faisant étape par étape
\end{enumerate}

\end{document}
