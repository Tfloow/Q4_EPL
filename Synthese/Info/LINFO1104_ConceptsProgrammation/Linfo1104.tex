%Made By Thomas Debelle
\documentclass{report}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{xcolor}
\usepackage{array}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{xparse}


\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
\begin{document}


\begin{titlepage}
    \begin{figure}
        \includegraphics[height = 2cm]{UCL_Logo.png}
        \label{fig:my_label}
    \end{figure}

    \hspace*{100cm}
    \centering
    \vspace*{7cm}

    {\Huge \textbf{Résumé de LINFO1104}}\\
    \vspace*{0.25cm}
    compilation du \today\\
    \vspace*{0.25cm}
    \Large{Thomas Debelle}\\

    \vspace*{9.5cm}
    {\Large Juin 2023}
\end{titlepage}


\tableofcontents
\newpage

\section*{Préface}

Bonjour à toi !\\

Cette synthèse recueille toutes les informations importantes données au cours, pendant les séances de tp et est amélioré grâce au note du Syllabus. Elle ne remplace pas le cours donc écoutez bien les conseils et potentielles astuces que les professeurs peuvent vous donner. Notre synthèse est plus une aide qui on l'espère vous sera à toutes et tous utiles.\\

Elle a été réalisée par toutes les personnes que tu vois mentionné. Si jamais cette synthèse a une faute, manque de précision, typo ou n'est pas à jour par rapport à la matière actuelle ou bien que tu veux simplement contribuer en y apportant ta connaissance ? Rien de plus simple ! Améliore la en te rendant \href{http://www.github.com/Tfloow/Q4_EPL}{ici} où tu trouveras toutes les infos pour mettre ce document à jour. (\textit{en plus tu auras ton nom en gros ici et sur la page du github})\\

Nous espérons que cette synthèse te sera utile d'une quelconque manière ! Bonne lecture et bonne étude.


\chapter{Introduction}
\section{Les Paradigmes}
Une paradigme, est une façon d'approcher et apporter une solution à un problème. De ce fait, chaque langage de programmation utilise 1 voir 2 paradigmes. Ce cours couvrira 5 paradigmes cruciaux qui sont:
\begin{enumerate}
\item "Functionnal Programming"
\item "Object Oriented Programming"
\item "Functional DataFlow Programming"
\item "Actor DataFlow Programming or Multi-Agent"
\item "Active Objects"
\end{enumerate}

Et pour découvrir ces paradigmes, nous utiliserons les langages de programmations "\href{https://fr.wikipedia.org/wiki/Oz_(langage)}{Oz}" qui est un langage de recherche multi paradigme ainsi que "\href{https://fr.wikipedia.org/wiki/Erlang_(langage)}{Erlang}" à la fin du cours.

\chapter{Les différents Paradigmes}
\section{Functional Programming}
Avec ce paradigme, on impose qu'une variable peut être nommé qu'une seule fois ! Donc: $X = 10$ mais on ne peut pas plus loin dire $X = 9$. $X$ est déjà attribué. On peut penser que cela risque d'être handicapant alors qu'en réalité, cela rend notre code plus simple à débuguer. De plus, nombreux sont les langages et microservices utilisés qui implémentent la programmation fonctionnelle.
Formellement, quand on déclare une variable et qu'on l'assigne à une valeur ceci se passe.
\begin{wrapfigure}{r}{.45\textwidth}
	\centering
    \includegraphics[width=.5\textwidth]{img/declVar.png}
    \caption{Déclaration d'une variable}
\end{wrapfigure}
Une chose importante à noter est que cette façon de programmer peut être réalisé dans n'importe quel langage de programmation. On peut également redéclarer un identificateur. C'est-à-dire écrire "$X = 42$" et plus loin en ayant redéclarer une variable "$X = 11$" car ces deux déclarations pointent à deux éléments totalement différents dans la mémoire et ont des \textit{scopes} différents.\\

Un "Scope" ou portée est une propriété centrale en programmation. En effet, c'est le scope qui nous permet d'avoir différente valeur pour des variables qui ont le même nom. Naturellement, elle ne représente pas la même chose car elle diffère de leur scope. On peut déterminer le scope d'une variable sans même exécuter le code. Il nous suffit d'analyser le code qui comprend un "\textcolor{red}{lexical scoping}" ou un "\textcolor{red}{static scoping}".
\begin{figure}[H]
\centering
\includegraphics[width=3cm]{img/scope.png}
\caption{Exemple de code avec des scope différents}
\end{figure}


\chapter{Programmation symbolique}
\section{Listes}
On dit d'une liste est \textbf{récursive} si elle se définit par elle-même. C'est-à-dire elle fait appel à elle-même. On utilise la récursion pour les calculs et pour stocker des données.
Une liste est soit vide ou soit une pair \textit{d'une valeur suivi par une autre liste}.
\subsection{Définition formelle}
En utilisant la notation \textbf{Extended Backus-Naur Form} ou \textit{EBNF} pour les intimes, on écrit une liste comme: <List T> ::= nil | T '|' <List T>. Une chose importante à noter est le deuxième "ou" qui s'écrit comme '|' signifiant qu'il n'appartient pas à la définition de List T mais plutôt à l'ensemble T '|' <List T>. Si on lit ceci, on dirait "\textit{Une list d'élément représentant T correspond à un élément vide ou un élément représentant T suivi d'une autre Liste d'élément T}.\\

\begin{wrapfigure}{r}{.35\textwidth}
	\centering
	\includegraphics[width=.3\textwidth]{img/listTree.png}
\end{wrapfigure}
Donc une List d'entier se définit comme: <List <Int> >. Une chose importante à remarquer est que j'ai utilisé le mot "représentation" en effet <Int> n'est pas un entier mais une représentation d'entier.\\

Pour définir une liste en Oz, on utilise soit la notation \textcolor{blue}{[1 2 3]} ou \textcolor{blue}{1 | 2 | 3 | nil}.(il existe d'autre manière semblable qu'on verra plus loin) C'est 2 déclarations reviennent à la même chose en mémoire. Une utilité des listes est leur facilité à être représenté sous forme d'arbre comme montré ci-contre. La \textit{head} est accessible via \textcolor{blue}{list.1} et la \textit{tail} est obtenu via \textcolor{blue}{list.2}.

\section{Pattern matching}
\begin{wrapfigure}{l}{.18\textwidth}
	\centering
	\includegraphics[width=.2\textwidth]{img/patternMatching.png}
\end{wrapfigure}
Grâce à cette représentation en arbre, il est facile de voir si une liste est bien une liste.\\
Ci-contre, on voit une fonction classique en Oz qui analyse une liste et détermine si elle est d'une structure correcte. Le \textcolor{blue}{[]} correspond au cas où l'élément \textcolor{blue}{L} est une liste avec une Head et une Tail. On appelle cela une \textit{Clause} et H|T est le pattern de la clause. Le premier cas est définit par \textcolor{blue}{of}.
\newpage

\section{Introduction au langage Kernel}
Le langage Kernel est la première partie de la sémantique formelle d'un langage de programmation. Une règle importante est que tout programme écrit en programmation fonctionelle \textit{peut être traduit en langage kernel}.
Les grands principes du langage Kernel sont:
\begin{itemize}
	\item Tous les résultats intermédiaires de calculs sont visibles. Donc on a 1 opération par ligne et la déclaration en locale de toutes les variables.
	\item Toutes les fonctions deviennent des \textit{procédures anonymes} avec un argument en plus. Cet argument donne le résultat de la fonction.
	\item Les fonctions dans une fonction sont sortis de leur fonction et on leur donne un nouvel identificateur.
\end{itemize}
Les résultats de la traduction: Les programmes Kernel sont plus longs mais on voit facilement comment un programme s'exécute et on voit si il est \textit{tail-recursive}

\section{Les arbres}
Les arbres sont des structures de données extrêmement utiles et utilisées. On peut y stocker des données spécifiques, faire des calculs, ... Les arbres illustrent bien \textit{la programmation orienté but}. Par le standard \textit{EBNF}, on définit un arbre comme suit: <tree T> ::= leaf | t(T <tree T> ... <tree T>). Donc un arbre est une feuille ou \textit{leaf} qui est suivie par un ensemble de \textit{sous-arbres} (Il faut noter que le $t(...)$ est une façon d'écrire un \textit{record} de label "\textit{t}" qui est vu au \ref{record}). Les arbres sont forts similaires au liste si ce n'est que les listes n'ont qu'une sous-listes alors qu'un arbre peut avoir plusieurs sous-arbres.

\subsection{Ordered Binary tree}
Un arbre de ce type a 2 particularités:
\begin{itemize}
\item \textcolor{red}{Binary}: toutes les éléments hors les feuilles possèdes 2 sous-arbres.
\item \textcolor{red}{Ordered}: pour chaque arbre, la clé à gauche est plus petite que la clé de l'arbre et la clé à droite est plus grande.
\end{itemize}
Ce type d'arbre est très utile pour; par exemple, effectuer des recherches binaires et permet de facilement et rapidement trouver des données.

\subsubsection{Lookup K T}
Nous permet de trouver une valeur. Ce programme est plutôt simple et il nous suffit de regarder la clé de l'arbre où on est. Puis on compare avec notre recherche, si on est plus grand, on va à droite sinon à gauche. On répète le processus jusqu'à trouver la clé.\\
Lookup est très efficace car il s'exécute en \textcolor{red}{$log_2 n$}, le pire cas est si l'arbre n'est pas équilibré et il ressemble à une liste. Mais en général, en ayant un nombre suffisant de données, il est très rare d'avoir un arbre non équilibré.
\subsubsection{Insert K W T}
Il existe 4 possibilités.
\begin{enumerate}
\item remplace une feuille.
\item on remplace un noeud.
\item on remplace un sous-arbre à gauche.
\item on remplace un sous-arbre à droite.
\end{enumerate}
Le premier cas est le plus simple car on créé simplement un nouvel sous-arbre avec 2 feuilles. Si on remplace un noeud, on change la clé et la valeur du noeud.
Pour remplacer un sous-arbre, on garde les mêmes clés et valeur de Y pour le noeud mais on change le sous-arbre à gauche ou à droite en fonction.
\subsubsection{Delete K T}
Celle-ci est plus compliqué, on a 4 possibilités
\begin{enumerate}
\item La valeur qu'on veut supprimer n'existe pas
\item On supprime une feuille.
\item on supprime un sous-arbre à gauche.
\item on supprime un sous-arbre à droite.
\end{enumerate}
\textcolor{red}{TODO} %ajouter le code et l'explication

\section{Tuples et Records}

\subsection{Tuples}
Un tuple est une manière de stocker des données de différents tuples, l'\textit{ordre} est \textit{important} dans un tuple. On doit également donné un nom, un \textbf{label}.
\begin{lstlisting}
X = state(1 b 2)
{Browse {Label X}}
{Browse {Width X}}
\end{lstlisting}
La première ligne défini un tuple ayant pour \textit{label} "state". La seconde ligne imprime le label du tuple. La dernière affiche sa taille. (c'est donc un entier toujours positif ou $0$)\\
Les champs dans les tuples sont numérotés de\textbf{ $1$ à width $X$}. On appelle aussi le champ (field) une "\textit{feature}". Un tuple possède toutes ces features de manière consécutives.\\

On peut donc ainsi construire des structures de données plus compliqués comme des arbres:
\begin{lstlisting}
declare
Y = left(1 2) Z = right(3 4)
X = mid(Y Z)
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{img/treeTuple.png}
\end{figure}
\subsubsection{Comparaison}
Il est très simple de comparer des tuples via "$==$", il faut simplement comparer leur value à chaque champ. Attention au \textit{loop} causé par les approches naïves.\\

\subsection{Similitude Tuples et liste}
En effet, une liste qui n'est autre que "H|T" peut facilement être traduit en tuple '|' (H T). Quand on peut déterminer un même élément via différentes manières, on appelle ça du \textit{sucre syntaxique}. Dans le \textit{kernel}, on fait au plus simple donc que des tuples.
\begin{lstlisting}[escapechar=\%]
List1 = [1 2 3]
List2 = (1:1 2:(1:2 2:(1:3 2:nil)))
List1 == List2 %//Vrai%
\end{lstlisting}

\subsection{Les Records} \label{record}
Les "\textit{records}" sont une \textbf{généralisation} des tuples. La différence avec les tuples est que le \textit{field} peut être n'importe quel valeur et ne doit pas être consécutif. Donc ceux-ci sont des \textit{records} corrects:
\begin{lstlisting}
X = state(a:1 2:a b:2)
Y = inv(3:a 2:b 1:c)

\end{lstlisting}
Donc la position d'une valeur et son \textit{field} n'importe plus et on peut déclarer dans le sens qu'on veut.\\
Si on ne nomme pas un \textit{field} dans un \textit{record}, Oz va attribuer un nombre commençant à $1$ et qui n'est pas utilisé par un autre champ.\\
\subsection{Résumé}
\begin{itemize}
\item Un \textit{atom} est un record de width $0$.
\item Un tuple est un record avec des champs étant numéroté de manière consécutive de $1$ à width $X$. (consécutive, donc on skip pas. pas forcément dans l'ordre dans la déclaration)
\item Une liste est réalisé avec des \textit{tuples} et des $(X \quad Y)$
\item $\textbf{1}$ seule \textit{structure de donné} dans le kernel pour rester simple.
\end{itemize}

\section{Sémantique Formelle}
\subsection{Les environnements}
Un environnement est une fonction qui passe des \textit{identifieurs} aux \textit{variables en mémoire} autrement dit: $E_1 = ({X \rightarrow x, Y \rightarrow y)}$

\subsubsection{Environnement contextuel}
Un \textit{environnement contextuel} d'une fonction contient tous les \textit{identificateurs} qui sont utilisés dans la fonction mais déclarés \textit{en dehors}. Donc ce sont des fonctions qui lorsqu'on appelle une variable va pointer en dehors du scope de la fonction.

\subsubsection{Stocker une Procédure}
Les procédures sont stocker dans la mémoire sous le forme de procédure anonyme symboliser par le "\$".
\begin{lstlisting}
local P Q in
	{Browse 'do something'}
	proc {Q}
		{P}
	end
	{Browse 'another something'}
end
\end{lstlisting}
Notre "proc {Q}" sera stocker comme: "q = (proc\{\$\}\{P\} end, \{$P\rightarrow p$\})". On lit donc, la procédure \textit{anonyme} (\$), fais un appel à P (\{P\}) et finit (end), son \textit{environnement contextuel} fait que lorsqu'on appelle "P" on va récupérer la valeur "p" en mémoire (\{$P\rightarrow p$\}). Donc on voit que l'\textit{environnement contextuel} est stocké avec le code de procédure.\\
On appelle également la valeur d'une procédure une "\textit{closure}" ou une "\textit{lexically scoped closure}" car elle ferme les identificateurs libres quand définis.\\
Donc l'avantage d'un environnement contextuel est d'être sûr qu'on appellera la bonne valeur même si elle est déclaré en dehors de la fonction.\\

Un \textit{identificateur libre} est un identificateur utilisé dans une \textit{fonction} qui est déclaré \textit{en dehors} de la fonction.\\
Les arguments d'une procédure \textbf{ne sont pas} des identificateurs libres car l'argument défini l'identificateur.

\subsection{Sémantique}
Il est important de comprendre le fonctionnement même d'un programme car si on ne comprend pas comment celui-ci fonctionne, il nous domine. \textit{If you do not understand something, then you do not master it – it masters you!}
\subsubsection{Définition}
La \textit{sémantique} d'un langage de programmation est une explication \textit{précise} de comment un programme s'exécute. Nous verrons la sémantique pour tous les paradigmes. Il en existe 4 types:
\begin{enumerate}
\item \textcolor{red}{Sémantique opérationnelle}: explique un programme sur base d'\textit{exécution} sur un PC simplifié appelé \textit{la machine abstraite}. $\rightarrow$ Fonctionne pour tous les paradigmes.
\item \textcolor{red}{Sémantique axiomatique}: explique un programme sur base d'\textit{implication}. C'est-à-dire que certaines \textit{propriétés} présent avant l'exécution, et d'autres seront présentes après. $\rightarrow$ très utilisé pour la programmation orienté objet comme \textit{Java}.
\item \textcolor{red}{Sémantique de notation}: explique un programme comme une \textit{fonction} sur un domaine abstrait. Donc simplifie l'analyse mathématique d'un programme. (utilisé dans \textit{Haskell} et \textit{Scheme})
\item \textcolor{red}{Sémantique logique}: explique un programme comme étant un \textit{modèle logique} basé sur des \textit{axiomes logiques}. Le résultat est une propriété correcte dérivé des axiomes. (cela est implémenté par exemple dans \textit{Prologue} ou dans la \textit{programmation sous contrainte})
\end{enumerate}

\subsection{Sémantique opérationnelle}
Ce type de sémantique à 2 parties majeures:
\begin{itemize}
\item \textcolor{red}{Langage Kernel}: traduit le programme en langage Kernel.
\item \textcolor{red}{Machine abstraite}: puis exécute le programme sur la machine abstraite.
\end{itemize}

\subsubsection{1. Langage Kernel complet}
Pour définir correctement une sémantique, il faut tout d'abord s'intéresser à son langage Kernel complet. On peut également prouver qu'un programme est correct en analysant son kernel. Par exemple, prenons ce code kernel:
\begin{lstlisting}[escapechar=\%]
<s> ::= skip 
	| %$<s>_1 <s>_2$% 
	| local <x> in <s> end 
	| %$<x>_1=<x>_2$% 
	| <x>=<v> 
	| if <x> then %$<s>_1$% else %$<s>_2$% end 
	| {<x> %$<y>_1,...,<y>_n$%} 
	| case <x> of <p> then %$<s>_1$% else %$<s>_2$% end

<v> ::= <number> | <procedure> | <record>  
<number> ::= <int> | <float> 
<procedure> ::= proc {$ %$<x>_1, ..., <x>_n$%} <s> end
<record>, <p> ::= <lit> | <lit>(%$<f>_1:<x>_1, ..., <f>_n:<x>_n$%)
\end{lstlisting}
donc "<s>" contient le programme exécuté, "<v>" est une structure de donné contenant différent type de structure de donné qui sont définis juste en dessous. 

\subsubsection{2. La machine abstraite}
Voici ci-dessous comment s'exécute un programme initialement.

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{img/kernel.png}
\includegraphics[width=5cm]{img/kernel1.png}
\caption{à gauche: programme écrit en Oz $\qquad$ à droite: état initiale d'exécution}
\end{figure}
Au début, l'environnement et la mémoire sont vides. L'état d'exécution est écrit typiquement comme:
\begin{lstlisting}[escapechar=\%]
([(<s>,E)], %$\sigma$)
\end{lstlisting} %trouver comment utiliser un code dans lst
Sur la machine abstraite, on va d'instructions en instructions. C'est-à-dire on descend petit à petit.
donc on a pour la suite:
\begin{figure}[H]
\centering
\includegraphics[width=5cm]{img/kernel2.png}
\includegraphics[width=5cm]{img/kernel3.png}
\caption{à gauche: on descend de 1 cran $\qquad$ à droite: on descend encore de 1 cran}
\end{figure}
On voit que au fur et à mesure qu'on descend, la pile de mémoire et d'environnement s'agrandit. Ensuite on va \textit{séparer} la \textit{composition séquentielle} comme suit:

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{img/kernel4.png}
\includegraphics[width=5cm]{img/kernel5.png}
\caption{à gauche: on sépare en deux $\qquad$ à droite: on attribue à b la valeur définit à gauche}
\end{figure}
Une nouvelle instruction va s'ajouter à cause du "then" de notre condition:

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{img/kernel6.png}
\includegraphics[width=3cm]{img/kernel7.png}
\caption{à gauche: la nouvelle instruction $\qquad$ à droite: les instructions sont vides, c'est fini}
\end{figure}

\subsubsection{3. Définir la machine abstraite}
\begin{itemize}
\item Pour chaque instructions dans le langage Kernel, on associe sa règle dans la machine abstraite
\item Chaque instructions prends un état d'exécution en entrée et sort un état d'exécution en sortie $\rightarrow (ST, \sigma)$.
\end{itemize}
L'instruction la plus simple est "\textcolor{blue}{skip}" car il fonctionne comme $([(skip, E), S_2, ..., S_n], \sigma)$ et renvoie $([S_2,..., S_n], \sigma)$ 

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Instructions & entrée & sortie\\
\hline
\textcolor{blue}{skip} & $1$ & $2$\\
\hline 
\textcolor{blue}{$(<s>_1 <s>_2)$} & $([(S_a S_b), S_2, ..., S_n], \sigma)$ & $([S_a, S_b, S_2, ..., S_n], \sigma)$\\
\hline 
\textcolor{blue}{local in <x> in <s> end} & $([(\text{local } <x> \text{ in } <s> \text{ end }, E)$ & $([(<s>, E+\{<x>\rightarrow x\})$\\
 & $, S_2, ..., S_n], \sigma)$ & $, S_2, ..., S_n], \sigma)$\\
\hline 
\end{tabular}
\end{center}
Il y a également d'autres types d'instructions dont on détaillera pas le langage en machine abstraite:

\begin{itemize}
\item \textcolor{blue}{<x>=<v> (crée et assigne une valeur)}: quand <v> est une procédure, on \textbf{doit} crée un environnement contextuel.
\item \textcolor{blue}{if <x> then $<s>_1$ else $<s>_2$ end (condition)} : si <x> n'est pas attribué, l'instruction va attendre (“\textit{block}”) jusqu'à ce que <x> soit attribuer à une valeur.
\item \textcolor{blue}{case <x> of <p> then $<s>_1$ else $<s>_2$ end} : Le system de "\textit{case}" se construit en combinant des structures de données Kernel.
\item \textcolor{blue}{\{$<x> <y>_1, ..., <y>_n$\}} : ceci est la base de l'abstraction de donnée
\end{itemize}
Par ailleurs, voici d'autres concepts de machine abstraite:
\begin{itemize}
\item \textcolor{blue}{Single-assignment memory }\textcolor{red}{$s = \{x_1=10, x_2, x_3=20\}$}: Définition d'une variable et la valeur associée.
\item \textcolor{blue}{Environnement }\textcolor{red}{$E = \{X \rightarrow x, Y \rightarrow y\}$}: Lien entre un identificateur et son lien dans la mémoire
\item \textcolor{blue}{Instruction sémantique }\textcolor{red}{$(<s>, E)$}: Une instruction avec son environnement.
\item \textcolor{blue}{Stack Sémantique }\textcolor{red}{$ST = [(<s>_1,E_1), ..., (<s>_n,E_n)]$}: Un stack d'instructions sémantiques.
\item \textcolor{blue}{État d'exécution }\textcolor{red}{$(ST,\sigma)$}: Une paire d'un stack sémantique et sa mémoire.
\item \textcolor{blue}{Execution }\textcolor{red}{$(ST_1,s_1) \rightarrow (ST_2,s_2) \rightarrow (ST_3,s_3) \rightarrow ...$}: Une séquence d'état d'exécution. 
\end{itemize}

\subsubsection{4. Programme correct}
grâce à la sémantique, on sait prouver qu'un programme est correct. On dit qu'un programme produit une solution correcte, on l'appelle une \textit{spécification}.\\
Donc on prouve qu'un programme satisfait la \textit{spécification} quand on utilise une certaine \textit{sémantique}. La sémantique lie le \textit{programme} à un résultat mathématique appelé \textit{spécification}.\\

Donc on lie une vérité mathématique à un programme. Et on prouve cela via ces différentes étaps: (exemple avec une factorielle)

\begin{enumerate}
\item On commence avec la spécification du programme.
\item Notre programme est \textit{récursif} donc on va utiliser une preuve mathématique par \textit{induction}.
\item On doit prouver le cas de base et le cas général.
\item On utilise la sémantique pour prouver la véracité de notre programme.
\end{enumerate}

\subsubsection{5. Procédures}
Les procédures sont la base de toutes \textcolor{red}{abstractions de données}.\\
Il y a deux choses importantes dans une \textit{procédure}: sa \textcolor{red}{définition} et son \textcolor{red}{appel}.\\

\textcolor{red}{Définition}: on crée l'environnement \textit{contextuel}. Puis, on stocke le code de la procédure et son environnement.\\

\textcolor{red}{Appel}: on crée un nouvel environnement combinant l'environnement \textit{contextuel} de la procédure et les variables \textit{formelles}. Ensuite, le tout est exécuté.
\begin{lstlisting}
local Z in 
	Z=1
	proc{P X Y}Y=X+Z end
end
\end{lstlisting}
Ici, le seul identificateur \textit{libre} est \textbf{Z} qui est donc déclaré en dehors de la \textit{procédure}. Donc à l'exécution de \textbf{P}, \textbf{Z} est connu donc \textbf{Z} fait partie de l'environnement contextuel de la \textit{procédure}.
\begin{lstlisting}
local P in
	local Z in 
		Z=1
		proc{P X Y}Y=X+Z end
	end
	local A B in
		A=10
		{P A B}
		{Browse B}
	end
end 
\end{lstlisting}
Ici, à la ligne de la création de la procédure P, son environnement contextuel est $E_c = \{Z \rightarrow z\}$.On va stocker dans la mémoire notre instruction et son environnement \textit{contextuel} c'est la \textit{semantic rule}. Au moment de l'exécution de P avec les valeurs A et B, on va donc ajouter un environnement qui est de la sorte: $E_P = \{Y \rightarrow b, X \rightarrow a, Z \rightarrow z\}$. Donc ce deuxième environnement est stocker dans le \textit{stack sémantique} \textbf{pas} dans la mémoire avec le fonction !
Donc en langage \textit{sémantique}, la définition d'une procédure ressemble à cela:
\begin{itemize}
\item \textbf{Instruction sémantique}: (<x>=\textcolor{blue}{proc}\{\$ $<x>_1, ..., <x>_n$\} <s> \textcolor{blue}{end}, E)
\begin{itemize}
\item \textbf{Arguments formels}: $<x>_1, ..., <x>_n$
\item \textbf{Identificateurs libres de <s>}: $<z>_1, ..., <z>_k$
\item \textbf{Environnement contextuel}: $E_C = E_{|<z>_1, ...n <z>_k}$ (que les identificateurs libres)
\end{itemize}
\item Cela crée une liaison en mémoire de la forme: x(\textcolor{blue}{proc}$\{\$<x>_1, ..., <x>_n\}$<s>, \textcolor{blue}{end}, $E_C$)
\end{itemize}
Maintenant, voyons pour un \textit{appel sémantique}:
\begin{itemize}
\item \textbf{Instruction sémantique}: (\{$\langle x \rangle \langle y \rangle_1 ... \langle y \rangle_n$\}, E)
\begin{itemize}
\item Si la condition est \textit{false} donc $E(\langle x \rangle)$ n'est pas lié.
\item Si $E(\langle x \rangle)$ n'est \textbf{pas} une procédure, on a une erreur de \textit{condition}.
\item Si $E(\langle x \rangle)$ est une procédure \textit{mais} avec le mauvais nombre d'argument, on a aussi une erreur de \textit{condition}.
\end{itemize}
\end{itemize}
Une chose primordiale à comprendre est comment sont stocké les instructions. Elles sont stocké sur une \textbf{pile} (\textit{stack}). Donc on a l'instruction sémantique sur le stack: (\{$\langle x \rangle \langle y \rangle_1 ... \langle y \rangle_n$\}, E) avec la définition de procédure dans la \textit{mémoire} comme cela: $E(\langle x \rangle) = proc\{\$ \langle z \rangle_1, ..., \langle z \rangle_n\} \langle s \rangle \text{end}, E_c)$ \\
Ensuite, on met ces instructions sur la \textit{pile} $(\langle s \rangle , E_C + \{\langle z \rangle_1 \rightarrow E(\langle y \rangle_1), ..., \langle z \rangle_n \rightarrow E(\langle y \rangle_n)\})$\\

La machine abstraite fait 2 choses:
\begin{enumerate}
\item \textcolor{red}{Adjonction}: $E_2 = E_1+\{X \rightarrow y\}$ Donc ajoute une paire (identificateur $\rightarrow$ variable) à l'environnement. Ré-écrit par dessus $E_1$ si existe déjà. Utile pour \textcolor{blue}{local} $<x>$ \textcolor{blue}{in} $<s>$ \textcolor{blue}{end}.
\item \textcolor{red}{Restriction}: $E_C = E_{|\{X,Y,Z\}}$ Donc limite les \textit{identificateurs} dans un environnement. On a besoin de cela pour calculer l'environnement \textit{contextuel}.
\end{enumerate}
Une adjonction:
\begin{lstlisting}[escapechar=\%]
local X in
	(E1) X=1 
	local X in 
		(E2) X=2 
		{Browse X}
	end 
end
E1 = {Browse %$\rightarrow$% b, X %$\rightarrow$% x}
E2 = E1 + {X %$\rightarrow$% y} = {Browse %$\rightarrow$% b, X %$\rightarrow$% y}
\end{lstlisting}
Une restriction:
\begin{lstlisting}[escapechar=\%]
local A B C AddB in
	A=1 B=2 C=3 %\textcolor{red}{(E)}%
	fun {AddB X} %\textcolor{red}{(EC: contextual environment)}%
		X+B
	end
end
E = {A %$\rightarrow$% a, B %$\rightarrow$% b, C %$\rightarrow$% c, AddB %$\rightarrow$% a' }
%$E_C$% = %$E_{|\{B\}}$% = {B %$\rightarrow$% b }
\end{lstlisting}
\subsection{Résumé}
Définir la sémantique permet de relier les programmes au mathématique. On donne des instructions \textit{sémantique} au \textit{kernel} pour qu'il sache comment exécuter dans la \textit{machine abstraite}. La sémantique nous permet de prouver qu'un programme est \textit{correct}.\\
La sémantique est au cœur de la programmation. Une nouvelle librairie est comme si on ajoutait des instructions au programme donc on augmente sa sémantique.\\
Quand on écrit un programme, il faut comprendre la sémantique (l'utilisateur n'a pas besoin de savoir). La sémantique doit être simple et complète.\\
On peut voir la sémantique comme le langage de programmation \textit{ultime}.\\
Il ne faut pas oublier que les pc sont baser sur les mathématiques \textit{discrètes}.

\section{Rappel procédure sémantique}
Tout d'abord, en programmation nous avons différentes étapes qui reposent chacun sur les précédentes. Fermeture $\rightarrow$ Programmation d'ordre supérieur $\rightarrow$ Abstraction des données $\rightarrow$ Technologie de l'information.\\

Rappel sur l'exécution d'un programme:
\begin{lstlisting}[escapechar=\%]
{Browse {Inc 10}}	#Langage pratique (classique)
%\hrulefill%
local M in		 	#Langage Kernel
	local N in
		M=10
		{Inc M N}
		{Browse N}
	end
end
\end{lstlisting}
A l'exécution,$[(\{Inc M N\},\{M\rightarrow m,N \rightarrow n,Inc \rightarrow i,Browse \rightarrow b\}), (\{Browse N\},\{M \rightarrow m,N \rightarrow n,Inc \rightarrow i,Browse \rightarrow b\})],
\{m=10,n,i=(proc \{\$ X Y\} Y=X+A end, \{A \rightarrow a\}), a=1,b=(... browser code…)\}$ et Inc va référencer cela:\\
$[(Y=X+A,\{A\rightarrow a,X \rightarrow m,Y \rightarrow n\}), (\{Browse N\},\{M \rightarrow m,N \rightarrow n,Inc \rightarrow i,Browse \rightarrow b\})],
\sigma$\\
Il est important de remarquer que dans la mémoire, quand on stocke une procédure, on stocke le tout donc avec son environnement contextuel.


\chapter{Programmation d'ordre supérieur}
Ce concept découle directement du concept d'\textit{environnement contextuel}. Dans un \textit{procédure} ou \textit{fonction} (les mêmes pour un langage kernel) peuvent prendre des valeurs ou des fonctions en arguments.
\subsubsection{Définition}
\begin{itemize}
\item Une fonction est dit \textcolor{red}{de premier ordre} si elle ne prend et ne ressort aucune fonction.
\item Une fonction est \textcolor{red}{N+1} si son entrée et sortie prennent en tout $N$ fonctions en argument.
\end{itemize}
Nomenclature des différentes fonctions:
\begin{itemize}
\item \textbf{Une génératrice} est le fait de prendre une fonction en entrée d'une fonction.
\item \textbf{Une instantiation} est le fait de retourner une fonction en sortie d'une fonction.
\item \textbf{Une composition de fonctions} est le fait de prendre 2 fonctions en entrée et on retourne leur composition.
\end{itemize}

\subsubsection{Utilisation}
Via la programmation d'ordre supérieure, on peut cacher un accumulateur. On dit qu'on fait une \textit{abstraction d'accumulateur}.\\
Une fonction type est la fonction \textbf{FoldL} (\textit{reduce}). En effet, la fonction FoldL fait:
\begin{lstlisting}
declare
fun {FoldL L F U}
	case L
	of nil then U
	[] H|T then {FoldL T F {F U H}}
	end
end

{FoldL LIST Function Acc}
\end{lstlisting}
On peut, un peu dans le même style, faire de l'encapsulation afin de cacher sa valeur à l'intérieur. $\rightarrow$ C'est la base de \textit{l'abstraction de donnés}.\\

Il faut faire attention à l'\textbf{exécution retardé}. En effet, si on ne stocke pas le résultat d'une fonction, elle ne sera exécuté que quand on appellera la valeur. Donc cela peut prendre beaucoup de place en mémoire de stocker une fonction plutôt que son résultat.

%Here

\chapter{Lambda Calcul}
\begin{enumerate}
\item C'est un modèle de calcul qui est \textcolor{red}{Turing complete}. 
\item \textbf{Tous} les types de données peuvent être encodé en lambda calcul.
\item Par le théorème de \textbf{Church-Rosser}, le lambda calcul est \textcolor{red}{confluent}. Même résultat peu importe l'ordre de réduction
\item C'est la base de la programmation ordre supérieur et de la programmation formelle.
\end{enumerate}
\section{Introduction}
Le \textit{lambda calcul} est une manière mathématique formelle pour représenter des calculs informatiques. Cela a été créé avant l'arrivée des ordinateurs. Cela ne contient que des \textbf{définitions}, \textbf{appels} et utilise des \textbf{liens de variables} et de la \textbf{substitution}.\\

Le \textit{lambda calcul} est une manière universelle de calcul. On peut l'utiliser pour simuler des \textbf{machines de Turing}.

\subsection{Fonctionnement}
Le lambda calcul n'a que des \textit{fonctions anonymes d'un seul argument}. Donc si on veut en avoir plusieurs, il faut combiner les fonctions:
\begin{lstlisting}[escapechar=\%]
sum_square(x,y) = %$x^2+y^2$ //fonction classique%
(x,y) %$\rightarrow x^2 + y^2$ //fonction anonyme%
x %$\rightarrow$% (y %$\rightarrow x^2 + y^2$%) %//d'une seul argument%
%$\lambda x. \lambda y. x^2+y^2$ //en lambda calcul%    
\end{lstlisting}
Le fait de combiner et de "\textit{nest}" des fonctions s'appellent le \textcolor{red}{currying}.

\subsection{Syntaxe}
Les expressions lambdas sont composées de:
\begin{itemize}
\item Variables (x,y, ...)
\item Du symboles d'abstractions ($\lambda$) et de point (.)
\item Et des parenthèses
\end{itemize}
En syntaxe EBNF c'est:
\begin{lstlisting}[escapechar=\%]
t ::= x | (%$\lambda$%x.t) | %$t_1 \quad t_2$%
\end{lstlisting}
($\lambda$x.t): est appelé une abstraction (\textit{définition de fonction})\\
$t_1 \quad t_2$: c'est \textit{l'appel de fonction}.

\subsection{En Oz}
\begin{enumerate}
\item La définition de fonction ($\lambda$x.t)
\begin{lstlisting}[escapechar=\%]
fun %\{\$ X\}% T end
\end{lstlisting}
\item L'appel de fonction ($t_1 \quad t_2$)
\begin{lstlisting}[escapechar=\%]
%\{$T_1 \quad T_2$\}%
\end{lstlisting}
\end{enumerate}
Le currying en Oz:
\begin{enumerate}
\item Définition
\begin{lstlisting}[escapechar=\%]
F = fun %\{\$ X\}% fun %\{\$ Y\}% T end end
\end{lstlisting}
\item Appel
\begin{lstlisting}[escapechar=\%]
%\{\{F X\} Y\}%
\end{lstlisting}
\end{enumerate}

\subsection{Sémantique des expressions lambdas}
Le sens d'une expression lambda dépend de comment on peut la réduire. Il en existe 3 types.
\begin{enumerate}
\item \textcolor{red}{$\alpha$-renaming}: change le nom des variables liés
\item \textcolor{red}{$\beta$-reduction}: applique une fonction à un argument
\item \textcolor{red}{$\eta$-reduction}: enlève les variables inutilisés
\end{enumerate}

\subsubsection{Variables libres et liées}	
Si nous avons: $\lambda x.t$ on dit que \textit{l'opérateur} $\lambda x$ lie la variable $x$ à $t$. Mais la variable $t$ est libre car n'est lié à \textit{aucune} fonction. Si $x$ est libre dans $t$ alors on dit qu'on \textcolor{blue}{capture} $x$.\\
On dénote $FV(t)$ l'ensemble des variables libres:
\begin{itemize}
\item $FV(x) = \{x\}$ où $x$ est une variable
\item $FV(\lambda x.t) = FV(t) \textbackslash \{x\}$
\item $FV((t_1 \quad t_2))=FV(t_1) \cup FV(t_2)$
\end{itemize}

\subsubsection{$\alpha$-renaming}
Ainsi, on peut changer le nom d'une variable lié:
\begin{lstlisting}[escapechar=\%]
%$\lambda$% x. x %$\rightarrow_{\alpha}\lambda$%y. y
\end{lstlisting}
Il faut faire attention à ce qu'on ait pas de \textit{conflit de nom} et de \textit{capture de variable}.\\
Des termes qui diffèrent d'un $\alpha$-renaming sont dits $\alpha$-équivalents.

\subsubsection{Substitution} \label{sub}
La substitution de $t_1[x:=t_2]$ remplace toutes les occurrences libres de x dans $t_1$ par $t_2$.\\
On a parfois recourt à l'$\alpha$-\textit{renaming}. En effet, la substitution ne peut pas \textit{capturer} des variables libres. Donc $(\lambda x.y)[y:=x]$ peut être transformé en $(\lambda z.y)[y:=x]$. La définition:
\begin{align*}
x[x:=t] &= t & y[x:=t]&=y, \text{ if } x \neq y & (t_1 \quad t_2)[x:=t]&= (t_1[x:=t])(t_2[x:=t])\\
(\lambda x.t_1)[x:=t_2]&= \lambda x.t_1 & (\lambda y.t_1)[x:=t_2]&= \lambda y.(t_1[x:=t_2]),& \text{ if } x &\neq y \wedge y \notin FV(t_2)
\end{align*}


\subsubsection{$\beta$-reduction}
C'est une application de fonction et se décrit via la substitution. (cfr \ref{sub})\\
Définition:  $(\lambda x.t_1) t_2 \rightarrow t_1[::=t_2]$\\
Exemple: $(\lambda x.(x \quad x))y \rightarrow (y \quad y)$

\subsubsection{$\eta$-reduction}
C'est l'idée que 2 fonctions sont les \textit{mêmes} si elles produisent le \textit{même résultat} pour tous les arguments possibles. On appelle cela \textcolor{red}{extensibilité}. Donc 2 fonctions sont les mêmes si elles ont les mêmes propriétés extérieures.\\
Définition: $\lambda x.(t \quad x) \rightarrow t$ if $x \notin FV(t)$

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{img/lambdaCal.png}
\caption{Résumé}
\end{figure}

\subsubsection{Convention de notation}
Quand on manipule des expression lambda, il est important de suivre quelques règles:
\begin{itemize}
\item Enlever les parenthèses les plus extérieur. ex: $(t_1 \quad t_2) \rightarrow t_1 \quad t_2$
\item Les applications sont associatives depuis la gauche. ex: $t_1 \quad t_2 \quad t_3 \rightarrow ((t_1 \quad t_2) \quad t_3)$
\item On étend vers la droite ex: $\lambda x.t_1 t_2 \rightarrow \lambda x.(t_1 t_2)$
\item On peut simplifier les séquences d'abstractions. ex: $\lambda x. \lambda y. \lambda z.t \rightarrow \lambda xyz.t$
\end{itemize}

\section{Types de données}
Le lambda calcul peut faire tout type de calcul, il est \textcolor{red}{Turing complete}.\\
Pour le démontrer, on va encoder des chiffres, opérations, ... en lambda calcul. Donc tous les chiffres, booléens, ... seront encodés en lambda calcul

\subsection{Nombres}
On utilise une notation appelée \textcolor{red}{Church Numerals}:
\begin{itemize}
\item $0 \triangleq \lambda f.(\lambda x.x)$
\item $1 \triangleq \lambda f.(\lambda x.(f \quad x))$
\item $2 \triangleq \lambda f.(\lambda x.(f (f \quad x))$
\item $3 \triangleq \lambda f.(\lambda x.(f (f (f \quad x))$
\end{itemize}
On peut remarquer que ces fonctions dont d'ordre supérieur. En effet, elles prennent en argument une fonction et ressort une fonction. (d'un seul argument)\\
Le nombre $n$ retourne donc la fonction qui est une composition de $n$ fois de f. Donc on dit que \textbf{f est appliqué n fois}.

\subsection{Opérations}
\subsubsection{Fonction successeur}
Prend le nombre de Church $n$ et retourne $n+1$.
\begin{align*}
SUCC &\triangleq \lambda n.\lambda f.\lambda x.f((n \quad f)x) & SUCC &\triangleq \lambda n.\lambda f.\lambda x.f(n \quad f \quad x)
\end{align*}

\subsubsection{Addition}
Retourne donc la composition de $m+n$.
\begin{align*}
PLUS &\triangleq \lambda m.\lambda n.\lambda f	. \lambda x.(m \quad f)((n \quad f)x) & PLUS &\triangleq \lambda m.\lambda n.\lambda f	. \lambda x.m \quad f(n \quad f \quad x)
\end{align*}

\subsubsection{Multiplication}
\begin{align*}
MULT &\triangleq \lambda m.\lambda n.\lambda f.m (n \quad f) & MULT &\triangleq \lambda m.\lambda n.m (PLUS \quad n)\quad 0
\end{align*}
La deuxième façon de faire $MULT$ est comme si on disait, "fait une somme m fois en commençant à 0.

\subsubsection{Exponentielle}
\begin{align*}
POW &\triangleq \lambda b.\lambda e.e \quad b
\end{align*}

\subsubsection{Prédécesseur}
\begin{align*}
PRED &\triangleq \lambda n.\lambda f.\lambda x.n (\lambda g.\lambda h.h (g f)) (\lambda u.u)
\end{align*}

\subsubsection{Soustraction}
Grâce à la méthode du prédécesseur, on peut définir la soustraction:
\begin{align*}
SUB \triangleq \lambda m.\lambda n.n \quad PRED \quad m
\end{align*}
Donc pour $m-n$ on effectue la fonction prédécesseur $n$ fois en commençant à $m$. 

\subsection{Opération logique}

\subsubsection{Booléens}
\begin{align*}
TRUE &\triangleq \lambda x.\lambda y.x & FALSE &\triangleq \lambda x.\lambda y.y
\end{align*}

\subsubsection{Opérateur logique}
\begin{align*}
AND &\triangleq \lambda p.\lambda q.p \quad q \quad p & OR &\triangleq \lambda p.\lambda q.p \quad p \quad q\\
NOT &\triangleq \lambda p.p \quad FALSE \quad TRUE & IFTHENELSE &\triangleq \lambda p.\lambda a.\lambda b.p \quad a \quad b
\end{align*} 

\subsubsection{Prédicat}
Ce sont des fonctions qui retournent une valeur booléenne:
\begin{align*}
ISZERO &\triangleq \lambda n.n (\lambda x.FALSE) TRUE & LEQ &\triangleq \lambda m.\lambda n.ISZERO (SUB \quad m \quad n)
\end{align*}

\subsubsection{Paire}
Ce sont des tuples de \textit{width = 2} et peuvent être définis en terme de booléens:
\begin{align*}
PAIR &= (x,y) \text{ le tuple} & PAIR &\triangleq \lambda x.\lambda y.\lambda f.f \quad x \quad y\\
FIRST &\triangleq \lambda p.p \quad TRUE & SECOND &\triangleq \lambda p.p \quad FALSE\\ 
NIL &\triangleq \lambda x.TRUE & NULL &\triangleq \lambda p.p (\lambda x.\lambda y.FALSE)
\end{align*}
Ceci nous introduit à l'abstraction de donnée. Une chose cruciale à comprendre est que depuis les 3 principes simples du lambda calcul, (définition de fonction, utilisation de fonction, des variables en arguments) on peut tout réaliser !

\subsubsection{Liste}
En sachant qu'une liste est un ensemble de valeur de nil, on sait utiliser des listes en lambda calcul. On peut même les utiliser pour "\textit{simplement}" définir la fonction PRED via SHIFTINC:
\begin{align*}
SHIFTINC &\triangleq \lambda x.PAIR (SECOND \quad x) (SUCC (SECOND \quad x)) \quad (m,n) \rightarrow (n,n+1)\\
PRED &\triangleq \lambda n.FIRST (n \quad SHIFTINC (PAIR \quad 0 \quad 0))
\end{align*}
En effet cela fonctionne car le premier élément sera $n-1$ par rapport au second.

\subsection{Fonctions récursives}
Comme les fonctions sont anonymes, on ne peut pas faire d'appel direct récursif. On va faire en sorte qu'une fonction devient l'argument d'une expression lambda. Par exemple:
$G \triangleq \lambda f.\lambda n.$(if n = 0 then 1 else n(f n-1))

\subsubsection{Y combinator}
Cela nous permet de passer de $Y(g)$ à $g(Y \quad g)$. Ainsi, on sait faire des factorielles de manière récursive:
\begin{align*}
Y \triangleq \lambda g.(\lambda x.g (x \quad x)) (\lambda x.g(x \quad x))
\end{align*}

\subsection{Théorème de Church-Rosser}
Ce théorème nous dit que l'\textbf{ordre de réduction} n'a pas d'importance.\\
Concrètement, si $a$ se réduit à $b$ avec aucune ou plusieurs étapes et que si $a$ se réduit à $c$ avec aucune ou plusieurs étapes. Alors, il existe un $d$ tel que $b$ et $c$ peuvent se réduire à ce dernier.\\
Le programme est \textcolor{red}{confluent} ou possède la \textit{propriété de Church-Rosser}.

\subsection{Le lambda calcul et les langages de programmation}
La \textit{programmation fonctionnelle} peut être comprise en terme de lambda calcul.
\begin{itemize}
\item Les valeurs de procédures (donc \textit{lexically scope closures}) \textbf{sont} des fonctions lambda.
\item l'\textit{Eager et lazy evaluation} est sont des stratégies de réduction différentes.
\end{itemize}

\subsubsection{2 approches}
\begin{tabular}{|c|c|}
Eager évaluation méthode de réduction & La lazy évaluation elle, va\\
qui commence par l'intérieur & calculer que ce qui est \\
 donc on exécute un programme comme suit: &  nécessaire et réduit si nécessaire pour \\
 & l'exécution. On va de l'extérieur à l'intérieur\\
  & \\
\includegraphics[width=4cm]{img/Eager.png} & \includegraphics[width=4cm]{img/Lazy.png}
\end{tabular}

\subsubsection{If statement}
Dans la plupart des langages de programmation, la condition \textcolor{blue}{if} est réalisé de manière applicative. La partie de l'action \textcolor{blue}{then} est réalisé de manière \textcolor{blue}{lazy}. Donc si une action produit une erreur mais quelle est dans une clause qui ne serait pas atteint, alors le programme ne crashe pas.

\subsection{Astuces pour le Lambda Calcul}
Voici quelques astuces pour vous aider à maitriser le lambda calcul qui peut sembler de prime abord barbare:
\begin{enumerate}
\item Ajouter des parenthèse !! Ex: $\lambda x.\lambda y.x + y \quad 1 \quad 2 \rightarrow (\lambda x.(\lambda y.x+y)1)2$ Cela peut sembler anodin mais cela permet de mieux comprendre et lire les expressions qui peuvent vite devenir lourdes. Aussi, garder les parenthèses ça peut aider à voir plus clair. 
\item Utiliser des abréviations. Car on n'a pas toujours besoin de savoir comment cela fonctionne et permet de faire partie par partie une fonction.
\item Pour bien réaliser un $\eta$\textit{-reduction}, commencer par faire une $\beta$\textit{-reduction}. Vous voyez ce qu'il vous reste. Vous faites une $\alpha$\textit{-renaming} pour retrouver une expression qui correspond à une partie de l'expression de base.
\item Cet \href{https://medium.com/@ayanonagon/the-y-combinator-no-not-that-one-7268d8d9c46}{article} est très utile pour comprendre le \textit{y-combinator} et mieux disséquer les opérations en Lambda Calcul.
\end{enumerate}

\subsection{Variation et extension}
Le lambda calcul est une base fondamentale dans la théorie de l'informatique. Dans les extensions du lambda calcul, on retrouve:
\begin{itemize}
\item \textcolor{red}{Lambda calcul typé}: donc avec des variables et fonctions
\item \textcolor{red}{System F}: avec des variables de \textbf{types}
\item \textcolor{red}{Constructions de calcul}: les types sont les valeurs de classes premières
\item \textcolor{red}{Combinateur logique}: logique sans variables
\item \textcolor{red}{Calcul de combinateur SKI}: comme le lambda calcul mais sans substitution de variables. On utilise les combinateurs S,K et I.
\item \textcolor{red}{Langage Kernel d'OZ}: le lambda calcul avec des variables \textit{dataflow}(une seule attribution), exécution \textit{dataflow}, \textit{threads} et evaluation \textit{lazy} explicite.
\end{itemize}

\chapter{État mutable et abstraction des données}
Une chose importante à réaliser, il n'y a pas de notion de temps en programmation. Toutes les fonctions qu'on a sont mathématiques et ne change pas en fonction du temps. Un programme \textit{ ne peut observer} son évolution dans le temps sur l'ordinateur.

\section{Motivation}
Une des solutions possibles, on définit le temps abstrait comme une suite de valeurs. On appelle cela un \textbf{état}. \\
Formellement, un \textcolor{blue}{state} est une séquence calculé de manière \textit{progressive} et contient les résultats \textit{intermédiaire}. Le paradigme fonctionnel peut utiliser les \textcolor{blue}{états}. ci-dessous la définition de \textbf{Sum} comme un état:
\begin{center}
\begin{tabular}{c|c}
\begin{lstlisting}[escapechar=\%]
fun {Sum Xs A}
	case Xs
	of nil then A
	[] X|Xr then
		{Sum Xr A+X}
	end
end
{Browse {Sum [1 2 3 4] 0}}
\end{lstlisting}
& \begin{lstlisting}[escapechar=\%]
Xs		A
[1 2 3 4]	0
[2 3 4]		1
[3 4]		3
[4]		6
nil		10    
\end{lstlisting}
\end{tabular}
\end{center}
Mais cela n'est pas suffisant. En effet, on voudrait que le programme remarque \textit{lui-même} ses propres changements. Il faut faire une \textbf{extensions}, on rentre dans un nouveau \textbf{paradigme}.

\section{État explicite}
On va essayer de montrer les changements en rendant les états \textit{explicites}. On appelle l'extension une \textbf{cellule} ou \textit{cell}(c'est l'équivalent d'un \textit{pointeur} en C).\\
Donc tout comme en C, on peut changer la référence en changeant le pointeur ou en remplaçant la variable par une autre valeur.

\subsubsection{Cell}
Une cellule à une \textcolor{red}{identité} et un \textcolor{red}{contenu}:

\begin{itemize}
\item \textcolor{red}{identité}: c'est constant et correspond au nom/pointeur de la cellule 
\item \textcolor{red}{contenu}: c'est le contenu stocké qui lui peut varier.
\end{itemize}

\begin{lstlisting}[escapechar=\%]
A=5; B=6
C={NewCell A}	%// on crée une nouvelle cellule%
{Browse @C}	%// on montre le \textit{contenu} avec @ ici 5%
C:=B		%// on ré-attribue le pointeur qui pointe vers B maintenant%
{Browse @C}	%// vaut 6%
\end{lstlisting}

\subsection{Exemple}
Une chose à bien comprendre est que lorsqu'on réalise l'opération $:=$, on remplace le contenu de la \textit{box}. Si on lie 2 cell via $=$ on relie notre variable vers la même cell. Donc on peut modifier le contenu de la box via une des deux variables. (\ref{pointerEx1})
\begin{figure}[H]
\centering
\includegraphics[width=6cm]{img/pointerEx1.png} \label{pointerEx1}
\includegraphics[width=6cm]{img/pointerEx2.png}
\end{figure}

\section{Sémantique de cellules}
On va maintenant étendre la machine abstraite afin d'expliquer comment les \textit{cells} fonctionnent.\\
Tout d'abord, nous avons maintenant \textbf{2 types de données}. Les données \textcolor{blue}{immutables} ou \textcolor{blue}{assignement unique} et les \textcolor{blue}{mutables} ou \textcolor{blue}{assignements multiples} (les cellules).\\
Une cellule est une paire de 2 \textit{variables}.
\begin{itemize}
\item Une variable constante qui est lié au nom de la \textit{cell}
\item Une variable qui est lié au contenu de la cellule
\end{itemize}
Quand on assigne du nouveau contenu à une \textit{cell}, on change la paire (seulement la deuxième variable).\\

Pour stocker le tout, on a 2 parties comme $\sigma = \sigma_1 \cup \sigma_2$.
\begin{itemize}
\item \textcolor{blue}{Single assignement}: $\sigma_1 = \{t,v,x=\xi,y = \zeta\}$
\item \textcolor{blue}{Multiple assignement}: $\sigma_2 = \{x:t, y:w\}$
\end{itemize}
Quand on réalise l'opération $X:=Z$ on change $\sigma_2$. $x:t \rightarrow x:z$

\subsection{Programmation impérative}
La \textbf{programmation impérative} est le nom du nouveau \textit{paradigme}. C'est donc le cumul du \textit{functional paradigm} et du concept de cellules.\\
La programmation impérative est fondamentale en \textbf{programmation orienté objet}.

\subsubsection{Langage Kernel de la programmation impérative}
\begin{lstlisting}[escapechar=\%]
<s> ::= skip 
	| %$<s>_1$% %$<s>_2$% 
	| local <x> in <s> end 
	| %$<x>_1=<x>_2$%
	| <x>=<v> 
	| if <x> then %$<s>_1$% else %$<s>_2$% end 
	| {%$<x>,<y>_1, ..., <y>_n$%} 
	| case <x> of <p> then %$<s>_1$% else %$<s>_2$% end 
	| {NewCell <y> <x>} 
	| <x>:=<y> ____ {Exchange <x> <y> <z>}
	| <y>=@<x> __|
<v> ::= <number> | <procedure> | <record> 
<number> ::= <int> | <float> 
<procedure> ::= proc {$ %$<x>_1,...,<x>_n$%} <s> end
<record>, <p> ::= <lit> | <lit>(%$<f>_1:<x>_1 ... <f>_n:<x>_n$%)
\end{lstlisting}
On remplace souvent l'attribution et l'appel du contenu par la fonction \textit{Exchange} qui est une opération atomique (c'est-à-dire 2 opérations indissociables en 1).

\section{Nécessité de l'état mutable}
On dit qu'un programme est modulaire pour une partie si on peut changer cette dernière sans changer le reste du programme.
\textcolor{red}{TODO ajouter plus d'info}

\subsection{Comparaison}
Dans la \textcolor{blue}{programmation fonctionnelle}
\begin{itemize}
\item Un composant \textbf{ne change jamais} de comportement (c'est permanent).
\item Mettre à jour un composant signifie que sont \textcolor{blue}{interface} change et donc on doit mettre à jour d'autres composants.
\end{itemize}
Dans la \textcolor{blue}{programmation impérative}
\begin{itemize}
\item Un composant peut être \textcolor{blue}{mis à jour} sans changer son interface et donc on ne doit pas tout mettre à jour.
\item Un composant peut changer de comportement à cause des actions passées sur une \textcolor{blue}{cellule}.
\end{itemize}
On peut avoir le meilleur des 2 mondes, en simplifiant les mises à jour de composants tout en s'assurant que les cellules se comportent comme on le souhaite.

\section{Abstraction des données}
C'est une des bases pour construire des logiciels complexes. L'abstraction des données est supportée par \textit{les fonctions d'ordre supérieur, static scoping et l'état explicite}. La première chose à réaliser est l'\textcolor{blue}{encapsulation}.

\subsection{Encapsulation}
C'est le fait de donner à l'utilisateur qu'un nombre \textit{limité} de fonctions et d'instanciations. Par exemple, une TV peut être commandé via une télécommande ayant un nombre limitée de fonction. Son fonctionnement est \textit{encapsuler} dans sa boite et l'utilisateur ne peut pas faire des modifications (\textit{techniquement}) à l'intérieur.

\subsubsection{Définition}
C'est donc une partie d'un programme qui a une partie \textit{extérieur} (au contact avec l'utilisateur) et une partie \textit{intérieur} (fonctionnement interne). Toutes les opérations à l'intérieur doivent passer par l'interface pour être donné à l'utilisateur.\\
On limite les \textit{fonctionnalités} et l'utilisateur doit suivre des règles établis de notre interface pour s'assurer que son résultat est bien correct.\\
L'\textcolor{blue}{encapsulation} doit être \textcolor{red}{supporté} par le langage de programmation.

\subsubsection{Avantage}
\begin{enumerate}
\item On garantit que si on utilise la partie \textit{extérieur}, les résultats sont corrects
\item On simplifie l'utilisation du programme:
	\begin{itemize}
	\item L'utilisateur \textbf{ne doit pas} savoir comment le programme fonctionne.
	\item On peut \textcolor{blue}{partitionner} notre programme pour simplifier le développement et l'utilisation
	\end{itemize}
\item On simplifie le développement de grands programmes. \textcolor{blue}{Un développeur} est responsable de \textcolor{blue}{son implémentation} et peut la maintenir.
\item Un développeur ne doit pas connaitre tout le code source pour utiliser les interfaces des autres développeurs.
\end{enumerate}

\subsection{Les 2 types}

\subsubsection{Objets}
On regroupe dans une même entité les \textcolor{blue}{valeurs et opérations}. Ex: la \textit{télévision}.

\subsubsection{Type de données abstraites}
On sépare les \textcolor{blue}{valeurs et opérations}. Ex: un \textit{distributeur de boisson}$\rightarrow$(\textit{on utilise un pièce (fonction) et on reçoit un objet})

\section{Le type de données abstraites}
Donc cela consiste a un ensemble de \textit{valeurs} et d'\textit{opérations}. Donc par exemple les nombres et les opérations arithmétiques usuelles.\\
Dans la plupart des \textit{ADT} les valeurs et les opérations n'ont pas \textbf{d'états}. Donc valeurs \textcolor{blue}{constante} et les opérations \textcolor{blue}{n'ont pas de mémoire interne}.\\
Donc par exemple pour un \textcolor{blue}{stack}, on l'instantie via une fonction qui nous retourne le type de données.\\

\subsection{Encapsulation}
Le problème avec cette implémentation vu au-dessus d'un stack est que les données ne sont pas protégées donc peuvent être modifier outre les interfaces.\\

On va \textcolor{red}{protéger} les données. On utilisera un \textcolor{red}{Security Wrapper}. On utilise ça comme suit:
\begin{lstlisting}[escapechar=\%]
{NewWrapper Wrap Unwrap} %\text{//crée une nouvelle clée d'encryption}%
W={Wrap X} %\text{//encrypte}%
X={Unwrap W} %\text{//décrypte}%
\end{lstlisting}
C'est donc une sorte d'encryption/décryption. Ainsi, on cache et empêche l'accès aux valeurs car on va encrypter les données primaires. L'utilisateur ne peut invoquer les fonctions Wrap et Unwrap.\\
Voici l'implémentation d'un stack:
\begin{lstlisting}[escapechar=\%]
local Wrap Unwrap in
  {NewWrapper Wrap Unwrap}

  fun {NewStack} {Wrap nil} end 
  fun {Push W X} {Wrap X|{Unwrap W}} end 
  fun {Pop W X} S={Unwrap W} in X=S.1 {Wrap S.2} end
  fun {IsEmpty W} {Unwrap W}==nil end
end
\end{lstlisting}

\subsection{Remarque}
Le premier langage de programmation à implémenter l'\textit{ADT} est \textcolor{blue}{CLU} et précédé de \textcolor{blue}{Simula 67} en 1967.\\
Ces langages supportent également la protection, ... De nombreux langages actuels supportent implicitement l'\textit{ADT} (par exemple: \textcolor{blue}{JAVA}, les nombres sont \textit{ADT} et les objets en java ont des propriétés \textit{ADT})

\section{Les objets}
Cela représente donc à la fois un ensemble de \textcolor{blue}{valeur et d'opérations}. Donc au début, on instantie notre stack. Par la suite on réalise des opérations de la sorte:
\begin{lstlisting}[escapechar=\%]
S={NewStack} 
{S push(X)} 
{S pop(X)}
{S isEmpty(B)
\end{lstlisting}
Donc on voit que notre $S$ est une sorte de fonction et instance, les deux à la fois. Concrètement, on implémente un objet pour un Stack comme ci-dessous:
\begin{lstlisting}[escapechar=\%]
fun {NewStack} 
	C={NewCell nil} 
	proc {Push X} C:=X|@C end 
	proc {Pop X} S=@C in C:=S.2 X=S.1 end 
	proc {IsEmpty B} B=(@C==nil) end
in
	proc {$ M}
		case M of push(X) then {Push X} 
		[] pop(X) then {Pop X} 
		[] isEmpty(B) then {IsEmpty B} end
	end
end
\end{lstlisting}
Chaque appel à NewStack va donc créer un nouvel \textcolor{blue}{objet}. Pour réaliser ses procédures, on passe 1 seul argument à notre objet. Pas besoin de Wrapper car on ne peut accéder à ces fonctions que via la création de l'objet stack. On le dissimule donc via le \textcolor{blue}{dynamic scoping}.

\subsection{Remarque}
De nos jours, les objets sont \textit{omniprésents} en programmation.\\
Ils sont apparus avec \textcolor{blue}{simula67} et a inspiré la plupart des langages actuels.\\
Cependant, la plupart des langages orientés objets sont en réalité des \textit{ADT} même s'ils incorporent les deux (\textit{ils ont en plus les modules et composants}).

\section{Les 4 types d'abstraction de données}
\begin{wrapfigure}{r}{.5\textwidth}
\centering
\includegraphics[width=7cm]{img/resAbstract.png}
\caption{Résumé de l'abstraction des données}
\end{wrapfigure}
Les 2 à ajouter sont:
\begin{enumerate}
\item Les types de données abstraites \textbf{avec état} (\textit{stateful ADT})
	\begin{enumerate}
	\item Très utilisé en C mais sans l'\textit{encapsulation} puisqu'impossible en C.
	\item On les retrouve dans les classes Java avec des attributs \textit{statiques}.
	\end{enumerate}
\item Les objets \textbf{sans état} (\textit{functional objects}):
	\begin{enumerate}
	\item Les objets sont \textcolor{red}{immutables} Donc appeler un objet, retourne un \textbf{nouvel} objet avec une \textbf{nouvelle} valeur
	\item Plus en plus à la mode (\textit{oue oue Scala \#EPFL})
	\end{enumerate}
\end{enumerate}

\subsection{Functional Objects}
\subsubsection{Constructions}
Un \textit{objet fonctionnel} n'a pas de sécurité (pas de cellules ni de wrappers) cela utilise que de la programmation \textcolor{red}{d'ordre supérieur}.
\begin{lstlisting}[escapechar=\%]
local 
  fun {StackObject S} 
    fun {Push E} {StackObject E|S} end 
    fun {Pop S1} 
      case S of X|T then S1={StackObject T} X end end 
    fun {IsEmpty} S==nil end
  in
    stack(push:Push pop:Pop isEmpty:IsEmpty) 
  end 
  in 
    fun {NewStack} {StackObject nil} end
  end
\end{lstlisting}

\subsubsection{En Scala}
C'est une sorte de forme hybride entre programmation fonctionnel et orienté objet. Scala supporte les 2 \textit{paradigmes}.\\
En Scala, on peut définir des objets immutables qui retournent, \textit{eux-mêmes}, des objets immutables.  Les objets immutables sont des objets \textit{fonctionnels}(\textit{donc pas de changement}).

\subsection{Stateful ADT}
Voici l'implémentation d'un stack en \textit{stateful ADT}:
\begin{lstlisting}[escapechar=\%]
local Wrap Unwrap 
  {NewWrapper Wrap Unwrap} 
  fun {NewStack} {Wrap {NewCell nil}} end 
  proc {Push S E} C={Unwrap S} in C:=E|@C end 
  fun {Pop S} C={Unwrap S} in 
    case @C of X|S1 then C:=S1 X end end 
  fun {IsEmpty S} @{Unwrap S}==nil end
in 
  Stack=stack(new:NewStack push:Push pop:Pop isEmpty:IsEmpty)
end
\end{lstlisting}
On utilise donc à la fois une \textcolor{blue}{cellule} et un \textcolor{blue}{wrapper}. Pour mettre à jour un stack, on n'utilise pas de \textit{wrapper} car on va utiliser des \textit{cellules} (ex: pour \textit{Push, Pop et IsEmpty})

\section{Remarques supplémentaires}
\begin{itemize}
\item Jave est designé pour supporter les abstractions de données:
	\begin{enumerate}
	\item True data abstraction (encapsulation, garbage collector)
	\item Tout entité en Java est un objet ou un \textbf{ADT}
	\item Supporte les principes de design orienté objet.
	\end{enumerate}
\item Scala a 2 grand principes:
	\begin{enumerate}
	\item Séparation entre les états mutables et immutables (programmation fonctionnelle)
	\item Tout est un objet (même les fonctions)
	\end{enumerate}
\end{itemize}
Scala, en plus de fonctionner sur la JVM, est un successeur important de Java et est très versatile via sa puissance expressive.

\section{Conclusion}
\noindent
L'abstraction des données est un concept \textcolor{red}{nécessaire} pour construire des programmes plus \textit{complexes}.
\begin{itemize}
\item L'abstraction des données est construite sur: \textit{la programmation d'ordre supérieure, le static scoping, les états explicites, les records et les clés secrètes}
\item L'abstraction des données est définie via ces concepts. Ainsi, on connait la sémantique de l'abstraction de donnée.
\end{itemize} 
Il existe 4 types d'abstraction des données orientées selon 2 axes: 
\begin{enumerate}
\item Objet et ADTs sur un axe
\item Stateful et Stateless
\end{enumerate} 
Il existe 2 types d'abstraction des données qui sont dominantes mais les 2 dernières sont toujours utiles pour certains types d'abstraction.\\
Quasi tous les langages de programmation modernes supportent l'abstraction. Ils supportent généralement \textcolor{blue}{plusieurs} types. Ils sont souvent plus des langages "\textit{orientés abstractions des données}" que simplement "\textit{objet orienté}".


\chapter{Les exceptions}
Une exception est lorsqu'un programme ne se comporte pas comme prévu ou que les inputs ne peuvent pas être utilisé (\textit{par exemple}: division par zéro, fichier non-existant, ...)\\
Ainsi, on peut faire fonctionner le programme même si il rencontre une erreur car celle-ci peut être "\textit{intercepté}" via une \textcolor{blue}{exception}.

\section{Fonctionnement}
On voudrait donc que le programme ne cesse pas quand il rencontre un soucis et on veut qu'une erreur impacte \textit{au minimum} le programme.\\
On utilise le principe du \textcolor{red}{confinement}.

\subsubsection{Le confinement}
\begin{wrapfigure}{r}{.5\textwidth}
\centering
\includegraphics[width=6cm]{img/handler.png}
\end{wrapfigure}
Donc notre programme est un \textcolor{blue}{ensemble imbriqué de contexte d'exécution}.\\
Donc si une erreur apparait, elle influence le contexte et pas tout le programme.\\
On protège chaque exécution par des \textit{exceptions handlers} qui sont comme des "douaniers" entre chaque zone de contexte. Ainsi, on s'assure que l'erreur est contenu et minimisée.

\subsection{En Oz}
On a les \textit{try} et \textit{raise} qui sont deux nouvelles instructions:
\begin{lstlisting}[escapechar=\%]
try <s1> catch <y> then <s2> end	#%On crée l'intercepteur%
raise <x> end				#%On établit une erreur%
\end{lstlisting}

\subsubsection{Try et Raise}
Le \textit{try} met un \textit{marker} sur le stack et puis exécute l'instruction $<S1>$.\\
Si il n'y a aucune erreur, l'instruction s'exécute normalement et le \textit{marker} est enlevé à la fin.\\
Si \textit{raise} est appelé pour signifier une erreur, le stack d'instructions est vidé jusqu'au \textit{marker}. Ensuite, on exécute $<s2>$. Dans notre exemple, $<y>$ est la même erreur que $<x>$. De plus, la porté de <y> est couvre exactement jusqu'à $<s2>$.

\subsubsection{Finally}
En plus de ces deux instructions, on peut rajouter une instruction s'appelant \textit{finally} qui comporte des étapes à exécuter peu importe si une erreur arrive ou pas.

\subsection{En Java}
C'est un objet hérité de la class des \textit{Exceptions} (elle-même sous-classe des \textit{Throwable)} et il existe 2 types d'exceptions:
\begin{itemize}
\item \textcolor{blue}{Checked exceptions}: le compilateur vérifie que les méthodes ne \textit{throw} que des exceptions déclaré pour la classe
\item \textcolor{blue}{Unchecked exceptions}: pour gérer les exceptions que le compilateur ne peut pas vérifier (\textit{les rayons cosmiques}). Elles héritent des \textit{RuntimeException} et \textit{Error}.
\end{itemize}
Donc en tant que développeur on check les erreurs \textit{checked}.

\subsection{Utilisation correcte}
On n'utilise pas une exception pour un comportement \textbf{attendu ou prévisible}. C'est-à-dire que, par exemple, on ne lit pas un fichier jusqu'au moment d'une erreur. Non, le fait que le fichier se finisse est prévisible et ne demande pas d'exception.


\chapter{Programmation simultanée}






\chapter{Conseils pour la syntaxe d'Oz}
Voici une liste d'astuces et de choses importantes à savoir sur Oz:
\begin{itemize}
\item Déclarer vos fonctions et variables avec une \textbf{majuscule} au début!
\item Une procédure est une fonction qui ne retourne \textbf{rien}.
\item Pour retourner une valeur dans une fonction, on écrit une ligne où on ne fait \textit{aucune} assignation ou opération, ... (Ex: on veut retourner $X$ on écrit sur une ligne $X$ tout seul)
\item Pour éviter d'avoir des surprises, toujours bien terminer sa liste par un $| nil$
\item On peut toujours utiliser une fonction récursive avec \textbf{accumulateur} pour une fonction récursive. C'est même conseillé !
\item On peut écrire en langage Kernel directement en oz
\item On peut faire des listes de procédures via la notation Kernel d'une procédure
\item Une liste est un tuple de type (1:Num 2:(1:Num 2:nil))
\item Pour être plus "opti" utiliser les local in.
\item Si notre code est le même que celui du voisin mais que vous avez des résultats différents, \textit{relancez emacs ou VScode}. Nettoyer le buffer et feed tout le code dedans.
\item Pour être plus \textit{productif}, télécharger "Powertoys" sur Windows et activer l'option "\textbf{toujours afficher}" (\textbf{always on top}).
\end{itemize}

\end{document}


